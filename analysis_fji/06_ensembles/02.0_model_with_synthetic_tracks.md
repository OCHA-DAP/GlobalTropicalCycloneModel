```python
import os
from pathlib import Path
import pandas as pd
import geopandas as gpd
import numpy as np
from sklearn.metrics import mean_squared_error
from xgboost.sklearn import XGBRegressor
import matplotlib.pyplot as plt
import seaborn as sns
from utils import get_combined_dataset, get_training_dataset_fji

from climada.hazard import Centroids, TCTracks, TropCyclone
from shapely.geometry import LineString
```


```python
# For Checking (Number of buildings destroyed per mun)
input_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_model_features/02_housing_damage/input/"
)
actual_mun_dmg = pd.read_csv(input_dir / "fji_building_damage_mun_complete.csv")
actual_mun_dmg['typhoon'] = actual_mun_dmg['typhoon'].str.upper()

# Load Fiji Shapefile
fiji = gpd.read_file(
    input_dir / "adm2_shp_fixed.gpkg"
)
fiji = fiji.to_crs('EPSG:4326')

# Load typhoon track
tracks_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_model_features/01_windfield"
)
typhoons_info = pd.read_csv(tracks_dir / "typhoons.csv")
typhoons_info.typhoon_name = typhoons_info.typhoon_name.str.upper()
cyclones = actual_mun_dmg['typhoon'].unique()
intersection = typhoons_info[typhoons_info['typhoon_name'].isin(cyclones)].drop_duplicates(keep='last', subset = ['typhoon_name'])

```

## Load data


```python
# Features
features = [
    "wind_speed",
    "track_distance",
    "total_houses",
    "rainfall_max_6h",
    "rainfall_max_24h",
    "coast_length",
    "with_coast",
    "mean_elev",
    "mean_slope",
    "IWI"
]
features_all = features + ['percent_houses_damaged','grid_point_id', 'typhoon_name']
```


```python
df_fji_complete = get_training_dataset_fji()
df_fji_complete = df_fji_complete.rename({
    'total_buildings':'total_houses',
    'mean_altitude':'mean_elev',
    'perc_dmg_grid': 'percent_houses_damaged'},
    axis=1)[features_all].sort_values('typhoon_name')
df_combined = get_combined_dataset()
```

Real paths


```python
df_combined['root_typhoon'] = df_combined['typhoon_name'].apply(lambda x: x.split('_')[0])
df_fji = df_combined[df_combined.country =='fji']
df_fji_complete['root_typhoon'] = df_fji_complete['typhoon_name'].apply(lambda x: x.split('_')[0])
```

## Stratification


```python
# Stratification
dmg = np.array(df_fji.percent_houses_damaged.to_list())
zero_dmg = np.round((np.count_nonzero(dmg == 0) / len(dmg)) , 2 )

# Define ranges for each group
x0 = list(np.linspace(0, zero_dmg, 1))   # zero damage
x1 = list(np.linspace(zero_dmg, 0.9, 2))  # almost no damage
x2 = list(np.linspace(0.935, 1, 5))  # all the damage
x3=x0+x1+x2

bins = []
for i in x3:
    bins.append(np.quantile(dmg, i))

# Histogram after stratification
samples_per_bin_fji, bins_def_fji = np.histogram(dmg, bins=bins)

# Define number of bins
num_bins = len(samples_per_bin_fji)

# For future plots
str_bin_fji = []
for i in range(len(bins_def_fji[:-1])):
    a = str(np.round(bins_def_fji[i+1],3))
    b = str(np.round(bins_def_fji[i],3))
    str_bin_fji.append('{} - {}'.format(b,a))
```

## Define model


```python
def xgb_model_LOOCV(df_combined, df_fji, features, bins, fji_weight=4, phl_weight=1, viet_weight=1):
    # Dataframe Fiji
    fji_typhoons = df_fji.root_typhoon.unique()
    fji_typhoons_synthetic = df_fji.typhoon_name.unique()
    y_test_typhoon_fji  = []
    y_pred_typhoon_fji  = []
    rmse_total = []
    rmse_bin = []
    for typhoon in fji_typhoons_synthetic:
        root_typhoon = typhoon.split('_')[0]

        """ PART 1: Train/Test """

        # LOOCV
        df_test = df_fji[df_fji["typhoon_name"] == typhoon] # Test set: Fiji
        df_train = df_combined[df_combined["root_typhoon"] != root_typhoon] # Train set: everything (drop synthetic ones)

        # Class weight
        weights = np.select(
            [
                (df_train['country'] == 'phl'),
                (df_train['country'] == 'viet'),
                (df_train['country'] == 'fji')
            ],
            [
                phl_weight,
                viet_weight,
                fji_weight
            ],
            default=1
        )

        # Split X and y from dataframe features
        X_test = df_test[features]
        X_train = df_train[features]

        y_train = df_train["percent_houses_damaged"]
        y_test = df_test["percent_houses_damaged"]

        # Stratify data
        bin_index_test = np.digitize(y_test, bins=bins[:-1])

        """ PART 2: XGB regressor """
        # create an XGBoost Regressor
        xgb = XGBRegressor(
            base_score=0.5,
            booster="gbtree",
            colsample_bylevel=0.8,
            colsample_bynode=0.8,
            colsample_bytree=0.8,
            gamma=3,
            eta=0.01,
            importance_type="gain",
            learning_rate=0.1,
            max_delta_step=0,
            max_depth=4,
            min_child_weight=1,
            missing=1,
            n_estimators=100,
            early_stopping_rounds=10,
            n_jobs=1,
            nthread=None,
            objective="reg:squarederror",
            reg_alpha=0,
            reg_lambda=1,
            scale_pos_weight=1,
            seed=None,
            silent=None,
            subsample=0.8,
            verbosity=0,
            eval_metric=["rmse", "logloss"],
            random_state=0,
        )

        # Fit the model
        eval_set = [(X_train, y_train)]
        xgb.fit(X_train, y_train, eval_set=eval_set, verbose=False, sample_weight=weights) #xgb_model

        # make predictions on Fiji
        y_pred_fji = xgb.predict(X_test)

        # Save y_test y_pred
        y_test_typhoon_fji.append(y_test)
        y_pred_typhoon_fji.append(y_pred_fji)

        # Calculate root mean squared error in total
        mse_test = mean_squared_error(y_test, y_pred_fji)
        rmse_test = np.sqrt(mse_test)
        rmse_total.append(rmse_test)

        # Per bin (Stratification)
        rmse_test_bin = []
        avg_error_bin = []
        for bin_num in range(num_bins)[1:]:
            if (len(y_test[bin_index_test == bin_num]) != 0 and len(y_pred_fji[bin_index_test == bin_num]) != 0):
                # Estimation of RMSE for test data per each bin
                mse_test = mean_squared_error(y_test[bin_index_test == bin_num], y_pred_fji[bin_index_test == bin_num])
                rmse_test = np.sqrt(mse_test)
                rmse_test_bin.append(rmse_test)

            else:
                rmse_test_bin.append(np.nan)
                avg_error_bin.append(np.nan)

        rmse_bin.append(rmse_test_bin)
        avg_error_bin.append(avg_error_bin)


    return y_test_typhoon_fji, y_pred_typhoon_fji, rmse_bin
```

## Apply model


```python
yasa_events = df_fji[df_fji.root_typhoon=='YASA']
```


```python
# Fji + Phl + Viet (with IWI)
y_test_typhoon_fji, y_pred_typhoon_fji, rmse_bin_fji = xgb_model_LOOCV(
    df_combined=df_combined,
    df_fji=df_fji,
    bins=bins_def_fji,
    fji_weight=4,
    phl_weight=1,
    features=features
)
```

## Results per bin


```python
# RMSE & Avg error per bin
rmse_strat = []
error_strat = []
for i in range(num_bins - 1):
    #RMSE
    test_rmse_bin = np.nanmean(np.array(rmse_bin_fji)[:,i])
    error_rmse_bin = np.nanstd(np.array(rmse_bin_fji)[:,i])
    rmse_strat.append(test_rmse_bin)
    error_strat.append(error_rmse_bin)
```

    /var/folders/dy/vms3cfrn4q9952h8s6l586dr0000gp/T/ipykernel_8335/196695075.py:6: RuntimeWarning: Mean of empty slice
      test_rmse_bin = np.nanmean(np.array(rmse_bin_fji)[:,i])
    /Users/federico/anaconda3/envs/env6/lib/python3.11/site-packages/numpy/lib/nanfunctions.py:1879: RuntimeWarning: Degrees of freedom <= 0 for slice.
      var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,



```python
fig, ax = plt.subplots(1,1, figsize=(6,6))

#ax.plot(range(num_bins)[1:], rmse_strat, 'ro', alpha=0.5, label='Trained on PHL typhoons')
ax.errorbar(range(num_bins)[1:], rmse_strat, yerr=error_strat, fmt='o', color='red', ecolor='k', alpha=0.5, label='Mean values over 5 synthetic tracks')

#ax.set_yscale('log')

ax.set_xticks(range(num_bins)[1:], str_bin_fji[1:], rotation=45)
ax.set_xlabel('Damage [%]')
ax.set_ylabel('RMSE')
ax.grid()
ax.set_title('XGBoost Regression model \n using LOOCV for Philippines typhoons')
ax.legend()

plt.tight_layout()
plt.show()
```



![png](02.0_model_with_synthetic_tracks_files/02.0_model_with_synthetic_tracks_16_0.png)



## Aggregate back at mun level


```python
# Load grids by mun
def get_municipality_grids():
    input_dir = (
        Path(os.getenv("STORM_DATA_DIR")) / "analysis_fji/02_model_features/02_housing_damage/input"
    )
    filename = input_dir / "grid_municipality_info.csv"
    return pd.read_csv(filename)
```


```python
# Calculate buildings destroyed by municipality and % of buildings destroyed by mun
mun_id = get_municipality_grids()[['id','NAME_2']]

def num_bld_destroyed_mun(mun, typhoon, y_pred_typhoon, df_fji, real=False):
    # Fiji typhoons
    fji_typhoons = df_fji.typhoon_name.unique()
    k = fji_typhoons.tolist().index(typhoon)

    df_typhoon = df_fji[df_fji.typhoon_name==typhoon]
    # Add feature "predictive_damage"
    df_typhoon['predicted_damage'] = y_pred_typhoon[k]

    mun_ids = mun_id[mun_id.NAME_2 == mun].id.to_list()
    cells_in_mun = df_typhoon[df_typhoon.typhoon_name == typhoon].set_index('grid_point_id').loc[mun_ids]

    if real:
        damage_grid = np.array(cells_in_mun.percent_houses_damaged.to_list()) # Real dmg
    else:
        damage_grid = np.array(cells_in_mun.predicted_damage.to_list()) # Dmg predicted by cell

    # Number of buildings
    N_bld_grid = np.array(cells_in_mun.total_houses.to_list()) # Bld by cell
    N_bld_mun = np.sum(N_bld_grid) # Total bld in mun

    # Calculate % of buildings (and N of bld) destroyed by mun
    N_bld_dest_pred_mun = np.sum(damage_grid) * (N_bld_mun / 100)
    perc_destroyed_mun = np.sum(damage_grid)

    return N_bld_dest_pred_mun, perc_destroyed_mun

def calculate_actual_perc_dmg(x, i, y_pred_typhoon, df_fji, typhoon):
    try:
        return num_bld_destroyed_mun(mun=x['NAME_2'], typhoon=typhoon, y_pred_typhoon=y_pred_typhoon, df_fji=df_fji, real=True)[i]
    except:
        return 0
def calculate_pred_perc_dmg(x, i, y_pred_typhoon, df_fji, typhoon):
    try:
        return num_bld_destroyed_mun(mun=x['NAME_2'], typhoon=typhoon, y_pred_typhoon=y_pred_typhoon, df_fji=df_fji, real=False)[i]
    except:
        return 0
```


```python
synthetic_names = df_fji[df_fji.root_typhoon == 'YASA'].typhoon_name.unique()
```


```python
typhoon = synthetic_names[0]
# Classic approach PHL+FJI+VIET
fiji_old = fiji.copy()
fiji_old['actual_perc_dmg'] = fiji_old.apply(calculate_actual_perc_dmg, df_fji=df_fji,
                                            y_pred_typhoon=y_pred_typhoon_fji, i=1, typhoon=typhoon, axis=1)
for j in range(len(synthetic_names)):
    fiji_old['pred_perc_dmg_gen{}'.format(j)] = fiji_old.apply(calculate_pred_perc_dmg, df_fji=df_fji,
                                        y_pred_typhoon=y_pred_typhoon_fji, i=1, typhoon=synthetic_names[j], axis=1)

```


```python
# Mean values over municipality
fiji_old['pred_perc_dmg'] = fiji_old.filter(like='pred_perc_dmg_gen').mean(axis=1)

# Modify values
fiji_old['actual_perc_dmg'] = fiji_old['actual_perc_dmg'].apply(lambda x: 0 if x < 0 else (100 if x > 100 else x))
fiji_old['pred_perc_dmg'] = fiji_old['pred_perc_dmg'].apply(lambda x: 0 if x < 0 else (100 if x > 100 else x))
# Now calculate prediciton error
fiji_old['prediction_error'] =  fiji_old['actual_perc_dmg'] - fiji_old['pred_perc_dmg'] # in percentual points

# STD
fiji_old['standard_deviation'] = fiji_old.filter(like='pred_perc_dmg_gen').std(axis=1)
```


```python
actual_dmg = fiji_old['actual_perc_dmg']
pred_dmg = fiji_old['pred_perc_dmg_gen0']

error_baseline = fiji_old['actual_perc_dmg'] - fiji_old['actual_perc_dmg'] #basically 0
error_old = fiji_old['prediction_error']
muns = fiji_old['NAME_2']
```


```python
# Define the standard deviation
std_deviation = fiji_old['standard_deviation']

# Plot the prediction errors with error bars
plt.errorbar(range(len(muns)), error_old, yerr=std_deviation, fmt='o-', label='Mean predicted damage', alpha=0.8, ecolor='k')
plt.plot(range(len(muns)), fiji_old['pred_perc_dmg_gen0'], 'o-', color='k', label='Mean ensemble')

# Plot the baseline error
plt.plot(error_baseline, 'o-', label='Perfect model', alpha=1)

# Set x-axis ticks and labels
plt.xticks(range(len(muns)), muns, rotation='vertical')

# Adjust layout to prevent overlapping
plt.tight_layout()

# Set title and axis labels
plt.title('Tropical Cyclone: {}, PHL+FJI+VIET model'.format(typhoon))
plt.ylabel('% Points of damage difference')

# Add grid and legend
plt.grid()
plt.legend(loc='upper left')

# Show the plot
plt.show()

```



![png](02.0_model_with_synthetic_tracks_files/02.0_model_with_synthetic_tracks_24_0.png)




```python
# Load track
id = intersection[intersection['typhoon_name'] == typhoon].typhoon_id.to_list()
track = TCTracks.from_ibtracs_netcdf(storm_id=id)
tc_track = track.get_track()

points_ib = gpd.points_from_xy(tc_track.lon, tc_track.lat)
tc_track_line_ib = LineString(points_ib)

geometries_ib = gpd.GeoSeries([tc_track_line_ib])
line_gdf_ib = gpd.GeoDataFrame(geometry=geometries_ib)

# Plots
cmap='Reds'
cmap_blue = 'Blues'
cmap_red = 'Reds_r'
```

    2024-03-25 14:49:49,940 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.



```python
from matplotlib.colors import Normalize
import matplotlib.patches as mpatches

fig, ax = plt.subplots(1, 3, figsize=(15, 5))
ax = ax.flatten()
# Check prediction_error column for values > 0 and < 0
positive_error = fiji_old[fiji_old['prediction_error'] >= 0]
negative_error = fiji_old[fiji_old['prediction_error'] < 0]


# Plotting the maps
fiji_plot_1 = fiji_old.plot(column='actual_perc_dmg', cmap=cmap, linewidth=0.2, ax=ax[0], edgecolor='0.3', legend=True)
fiji_plot_2 = fiji_old.plot(column='pred_perc_dmg', cmap=cmap, linewidth=0.2, ax=ax[1], edgecolor='0.3', legend=True)
fiji_plot_3_blue = positive_error.plot(column='prediction_error', cmap=cmap_blue, linewidth=0.2, ax=ax[2], edgecolor='0.3', vmin=0, legend=True)
fiji_plot_3_red = negative_error.plot(column='prediction_error', cmap=cmap_red, linewidth=0.2, ax=ax[2], edgecolor='0.3', vmax=0, legend=True)


line_gdf_ib.plot(ax=ax[0], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black
line_gdf_ib.plot(ax=ax[1], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black
line_gdf_ib.plot(ax=ax[2], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black


# Create custom legends
blue_patch = mpatches.Patch(color='#6495ED', label='Underestimated damage')
red_patch = mpatches.Patch(color='#800000', label='Overestimated damage')
ax[2].legend(handles=[blue_patch, red_patch], loc='lower left', bbox_to_anchor=(-0.05, -0.2))

ax[0].set_title('Actual Damage by municipality')
ax[1].set_title('Typhoon {} PHL+FJI+VIET model (FJI-PHL 4:1 ratio) \n \nMean Predicted Damage by municipality'.format(typhoon))
ax[2].set_title('Prediction Error \n $actual_{dmg} - predicted_{dmg}$ \n(in percentage points)', y=0.95)

ax[0].axis('off')
ax[1].axis('off')
ax[2].axis('off')


# All Fiji map
ax[0].set_xlim(176, 182)
ax[0].set_ylim(-20, -12)
ax[1].set_xlim(176, 182)
ax[1].set_ylim(-20, -12)
ax[2].set_xlim(176, 182)
ax[2].set_ylim(-20, -12)

plt.tight_layout()
plt.show()
```



![png](02.0_model_with_synthetic_tracks_files/02.0_model_with_synthetic_tracks_26_0.png)
