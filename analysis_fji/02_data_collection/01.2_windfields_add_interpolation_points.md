```python
from pathlib import Path
import os

from climada.hazard import Centroids, TCTracks, TropCyclone
from shapely.geometry import LineString
import geopandas as gpd
import numpy as np
import pandas as pd
import xarray as xr
import matplotlib.pyplot as plt

import warnings

# Ignore specific UserWarnings globally
warnings.filterwarnings("ignore", message="Geometry is in a geographic CRS.*")
warnings.filterwarnings("ignore", message="Use 'GeoSeries.to_crs()'.*")
```


```python
DEG_TO_KM = 111.1  # Convert 1 degree to km
input_dir = Path(os.getenv("STORM_DATA_DIR")) / "analysis_fji/02_model_features"
```

## Get typhoon data


```python
# Import list of typhoons to a dataframe
typhoons_df = pd.read_csv(input_dir / "01_windfield/typhoons.csv")

# House impact data
housing_path_in = input_dir / '02_housing_damage/input'
df_housing = pd.read_csv(housing_path_in / 'fji_impact_data/processed_house_impact.csv')

# The typhoons we have access to
cyclones = df_housing['Cyclone Name'].unique()
intersection = typhoons_df[typhoons_df['typhoon_name'].isin(cyclones)].drop_duplicates(keep='last', subset = ['typhoon_name'])
```


```python
# Download NECESARY tracks
sel_ibtracs = []
for track in intersection.typhoon_id:
    sel_ibtracs.append(TCTracks.from_ibtracs_netcdf(storm_id=track))
```

    2024-02-29 16:48:24,556 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-02-29 16:48:27,536 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-02-29 16:48:30,553 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-02-29 16:48:33,489 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-02-29 16:48:36,573 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-02-29 16:48:39,540 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-02-29 16:48:42,711 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-02-29 16:48:45,690 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-02-29 16:48:48,841 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.



```python
# Fix Tomas
#obs: .interp(x0,x,f(x)) gives the position of x0 in the fitting of (x,f(x))
#obs: daterange consider the track between certain intervals as discrete points instead of a continuous
tc_tracks = TCTracks()
for track in sel_ibtracs:
    tc_track = track.get_track()
    if tc_track.sid == '2010069S12188': #Tomas
        tc_track['lon'] *= -1
    tc_track.interp(
        time = pd.date_range(tc_track.time.values[0], tc_track.time.values[-1], freq="30T")
    )
    tc_tracks.append(tc_track)
```

## The situation

Create windfield at grid level


```python
# Just grid-land overlap
filepath = (
    input_dir
    / "02_housing_damage/output/fji_0.1_degree_grid_centroids_land_overlap_new.gpkg"
)
gdf = gpd.read_file(filepath)

# Include oceans
filepath_complete = (
    input_dir
    / "02_housing_damage/output/fji_0.1_degree_grid_centroids_new.gpkg"
)
gdf_all = gpd.read_file(filepath_complete)

# Centroids
cent = Centroids.from_geodataframe(gdf) # grid-land overlap
cent_all = Centroids.from_geodataframe(gdf_all)
cent_all.set_dist_coast(precomputed=True) # include oceans

# Trop cyclone
tc = TropCyclone.from_tracks(
    tc_tracks, centroids=cent, store_windfields=True, intensity_thres=0
)
tc_all = TropCyclone.from_tracks(
    tc_tracks, centroids=cent_all, store_windfields=True, intensity_thres=0
)
```

    2024-02-29 16:49:01,014 - climada.hazard.centroids.centr - WARNING - Centroids.from_geodataframe has been deprecated and will be removed in a future version. Use ther default constructor instead.
    2024-02-29 16:49:01,017 - climada.hazard.centroids.centr - WARNING - Centroids.from_geodataframe has been deprecated and will be removed in a future version. Use ther default constructor instead.



```python
def windfield_to_grid(tc, tracks, grids):
    df_windfield = pd.DataFrame()

    for intensity_sparse, event_id in zip(tc.intensity, tc.event_name):
        # Get the windfield
        windfield = intensity_sparse.toarray().flatten()
        npoints = len(windfield)
        # Get the track distance
        tc_track = tracks.get_track(track_name=event_id)
        points = gpd.points_from_xy(tc_track.lon, tc_track.lat)
        tc_track_line = LineString(points)
        DEG_TO_KM = 111.1
        tc_track_distance = grids["geometry"].apply(
            lambda point: point.distance(tc_track_line) * DEG_TO_KM
        )
        # Add to DF
        df_to_add = pd.DataFrame(
            dict(
                typhoon_name=[tc_track.name] * npoints,
                track_id=[event_id] * npoints,
                grid_point_id=grids["id"],
                wind_speed=windfield,
                track_distance=tc_track_distance,
                geometry = grids.geometry
            )
        )
        df_windfield = pd.concat([df_windfield, df_to_add], ignore_index=True)
    return df_windfield

# Define a function to calculate mean values for neighboring cells
def calculate_mean_for_neighbors(idx, gdf, buffer_size):
    row = gdf.iloc[idx]
    if row['wind_speed'] == 0:  # Check if wind_speed is 0
        buffered = row['geometry'].buffer(buffer_size)  # Adjust buffer size as needed

        # Find neighboring geometries that intersect with the buffer, excluding the current geometry
        neighbors = gdf[~gdf.geometry.equals(row['geometry']) & gdf.geometry.intersects(buffered)]

        if not neighbors.empty:
            # drop rows with 0 windspeed vals (we dont want to compute the mean while considering these cells)
            neighbors = neighbors[neighbors['wind_speed'] !=0]
            if len(neighbors) !=0:
                mean_val = neighbors['wind_speed'].mean()
            else:
                mean_val = 0
            return mean_val
    return row['wind_speed']  # Return the original value if no neighbors or wind_speed != 0
```


```python
df_windfield = windfield_to_grid(tc_all, tc_tracks, gdf_all)
```


```python
# Colormap Yasa
yasa_geo = gpd.GeoDataFrame(df_windfield[df_windfield.track_id == '2020346S13168'], geometry='geometry')

# Load track for Yasa
id = intersection[intersection['typhoon_name'] == 'Yasa'].typhoon_id.to_list()
track = TCTracks.from_ibtracs_netcdf(storm_id=id)
tc_track = track.get_track()
points_ib = gpd.points_from_xy(tc_track.lon, tc_track.lat)
tc_track_line_ib = LineString(points_ib)
geometries_ib = gpd.GeoSeries([tc_track_line_ib])
yasa_track_points = gpd.GeoDataFrame(geometry=points_ib)
line_gdf_ib_yasa = gpd.GeoDataFrame(geometry=geometries_ib)

fig, ax = plt.subplots(1,1, figsize=(5,5))
yasa_geo.plot(column='wind_speed', ax=ax, legend=True, colormap='Reds', label= 'Windspeed [m/s]')
line_gdf_ib_yasa.plot(ax=ax, color='k', linewidth=1, label='Typhoon track')
yasa_track_points.plot(ax=ax, color='k', linewidth=0.01)
ax.set_title('Yasa original track \nWindspeed [m/s]')
ax.set_xlim(176.5, 182)
ax.set_ylim(-20, -12)
ax.set_xticks([])
ax.set_yticks([])

plt.show()

```

    2024-02-29 16:58:19,356 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.


    /var/folders/dy/vms3cfrn4q9952h8s6l586dr0000gp/T/ipykernel_77825/3759466109.py:15: FutureWarning: 'colormap' is deprecated, please use 'cmap' instead (for consistency with matplotlib)
      yasa_geo.plot(column='wind_speed', ax=ax, legend=True, colormap='Reds', label= 'Windspeed [m/s]')




![png](01.2_windfields_add_interpolation_points_files/01.2_windfields_add_interpolation_points_11_2.png)



## Add interpolation points


```python
i=-2 # Yasa

# Define relevant features
track_xarray = tc_tracks.get_track()[i]
time_array = np.array(track_xarray.time)
time_step_array = np.array(track_xarray.time_step)
lat_array = np.array(track_xarray.lat)
lon_array = np.array(track_xarray.lon)
max_sustained_wind_array = np.array(track_xarray.max_sustained_wind)
central_pressure_array = np.array(track_xarray.central_pressure)
environmental_pressure_array = np.array(track_xarray.environmental_pressure)
r_max_wind_array = np.array(track_xarray.radius_max_wind)
r_oci_array = np.array(track_xarray.radius_oci)


track_xarray
```




<div><svg style="position: absolute; width: 0; height: 0; overflow: hidden">
<defs>
<symbol id="icon-database" viewBox="0 0 32 32">
<path d="M16 0c-8.837 0-16 2.239-16 5v4c0 2.761 7.163 5 16 5s16-2.239 16-5v-4c0-2.761-7.163-5-16-5z"></path>
<path d="M16 17c-8.837 0-16-2.239-16-5v6c0 2.761 7.163 5 16 5s16-2.239 16-5v-6c0 2.761-7.163 5-16 5z"></path>
<path d="M16 26c-8.837 0-16-2.239-16-5v6c0 2.761 7.163 5 16 5s16-2.239 16-5v-6c0 2.761-7.163 5-16 5z"></path>
</symbol>
<symbol id="icon-file-text2" viewBox="0 0 32 32">
<path d="M28.681 7.159c-0.694-0.947-1.662-2.053-2.724-3.116s-2.169-2.030-3.116-2.724c-1.612-1.182-2.393-1.319-2.841-1.319h-15.5c-1.378 0-2.5 1.121-2.5 2.5v27c0 1.378 1.122 2.5 2.5 2.5h23c1.378 0 2.5-1.122 2.5-2.5v-19.5c0-0.448-0.137-1.23-1.319-2.841zM24.543 5.457c0.959 0.959 1.712 1.825 2.268 2.543h-4.811v-4.811c0.718 0.556 1.584 1.309 2.543 2.268zM28 29.5c0 0.271-0.229 0.5-0.5 0.5h-23c-0.271 0-0.5-0.229-0.5-0.5v-27c0-0.271 0.229-0.5 0.5-0.5 0 0 15.499-0 15.5 0v7c0 0.552 0.448 1 1 1h7v19.5z"></path>
<path d="M23 26h-14c-0.552 0-1-0.448-1-1s0.448-1 1-1h14c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path>
<path d="M23 22h-14c-0.552 0-1-0.448-1-1s0.448-1 1-1h14c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path>
<path d="M23 18h-14c-0.552 0-1-0.448-1-1s0.448-1 1-1h14c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path>
</symbol>
</defs>
</svg>
<style>/* CSS stylesheet for displaying xarray objects in jupyterlab.
 *
 */

:root {
  --xr-font-color0: var(--jp-content-font-color0, rgba(0, 0, 0, 1));
  --xr-font-color2: var(--jp-content-font-color2, rgba(0, 0, 0, 0.54));
  --xr-font-color3: var(--jp-content-font-color3, rgba(0, 0, 0, 0.38));
  --xr-border-color: var(--jp-border-color2, #e0e0e0);
  --xr-disabled-color: var(--jp-layout-color3, #bdbdbd);
  --xr-background-color: var(--jp-layout-color0, white);
  --xr-background-color-row-even: var(--jp-layout-color1, white);
  --xr-background-color-row-odd: var(--jp-layout-color2, #eeeeee);
}

html[theme=dark],
body[data-theme=dark],
body.vscode-dark {
  --xr-font-color0: rgba(255, 255, 255, 1);
  --xr-font-color2: rgba(255, 255, 255, 0.54);
  --xr-font-color3: rgba(255, 255, 255, 0.38);
  --xr-border-color: #1F1F1F;
  --xr-disabled-color: #515151;
  --xr-background-color: #111111;
  --xr-background-color-row-even: #111111;
  --xr-background-color-row-odd: #313131;
}

.xr-wrap {
  display: block !important;
  min-width: 300px;
  max-width: 700px;
}

.xr-text-repr-fallback {
  /* fallback to plain text repr when CSS is not injected (untrusted notebook) */
  display: none;
}

.xr-header {
  padding-top: 6px;
  padding-bottom: 6px;
  margin-bottom: 4px;
  border-bottom: solid 1px var(--xr-border-color);
}

.xr-header > div,
.xr-header > ul {
  display: inline;
  margin-top: 0;
  margin-bottom: 0;
}

.xr-obj-type,
.xr-array-name {
  margin-left: 2px;
  margin-right: 10px;
}

.xr-obj-type {
  color: var(--xr-font-color2);
}

.xr-sections {
  padding-left: 0 !important;
  display: grid;
  grid-template-columns: 150px auto auto 1fr 20px 20px;
}

.xr-section-item {
  display: contents;
}

.xr-section-item input {
  display: none;
}

.xr-section-item input + label {
  color: var(--xr-disabled-color);
}

.xr-section-item input:enabled + label {
  cursor: pointer;
  color: var(--xr-font-color2);
}

.xr-section-item input:enabled + label:hover {
  color: var(--xr-font-color0);
}

.xr-section-summary {
  grid-column: 1;
  color: var(--xr-font-color2);
  font-weight: 500;
}

.xr-section-summary > span {
  display: inline-block;
  padding-left: 0.5em;
}

.xr-section-summary-in:disabled + label {
  color: var(--xr-font-color2);
}

.xr-section-summary-in + label:before {
  display: inline-block;
  content: '►';
  font-size: 11px;
  width: 15px;
  text-align: center;
}

.xr-section-summary-in:disabled + label:before {
  color: var(--xr-disabled-color);
}

.xr-section-summary-in:checked + label:before {
  content: '▼';
}

.xr-section-summary-in:checked + label > span {
  display: none;
}

.xr-section-summary,
.xr-section-inline-details {
  padding-top: 4px;
  padding-bottom: 4px;
}

.xr-section-inline-details {
  grid-column: 2 / -1;
}

.xr-section-details {
  display: none;
  grid-column: 1 / -1;
  margin-bottom: 5px;
}

.xr-section-summary-in:checked ~ .xr-section-details {
  display: contents;
}

.xr-array-wrap {
  grid-column: 1 / -1;
  display: grid;
  grid-template-columns: 20px auto;
}

.xr-array-wrap > label {
  grid-column: 1;
  vertical-align: top;
}

.xr-preview {
  color: var(--xr-font-color3);
}

.xr-array-preview,
.xr-array-data {
  padding: 0 5px !important;
  grid-column: 2;
}

.xr-array-data,
.xr-array-in:checked ~ .xr-array-preview {
  display: none;
}

.xr-array-in:checked ~ .xr-array-data,
.xr-array-preview {
  display: inline-block;
}

.xr-dim-list {
  display: inline-block !important;
  list-style: none;
  padding: 0 !important;
  margin: 0;
}

.xr-dim-list li {
  display: inline-block;
  padding: 0;
  margin: 0;
}

.xr-dim-list:before {
  content: '(';
}

.xr-dim-list:after {
  content: ')';
}

.xr-dim-list li:not(:last-child):after {
  content: ',';
  padding-right: 5px;
}

.xr-has-index {
  font-weight: bold;
}

.xr-var-list,
.xr-var-item {
  display: contents;
}

.xr-var-item > div,
.xr-var-item label,
.xr-var-item > .xr-var-name span {
  background-color: var(--xr-background-color-row-even);
  margin-bottom: 0;
}

.xr-var-item > .xr-var-name:hover span {
  padding-right: 5px;
}

.xr-var-list > li:nth-child(odd) > div,
.xr-var-list > li:nth-child(odd) > label,
.xr-var-list > li:nth-child(odd) > .xr-var-name span {
  background-color: var(--xr-background-color-row-odd);
}

.xr-var-name {
  grid-column: 1;
}

.xr-var-dims {
  grid-column: 2;
}

.xr-var-dtype {
  grid-column: 3;
  text-align: right;
  color: var(--xr-font-color2);
}

.xr-var-preview {
  grid-column: 4;
}

.xr-index-preview {
  grid-column: 2 / 5;
  color: var(--xr-font-color2);
}

.xr-var-name,
.xr-var-dims,
.xr-var-dtype,
.xr-preview,
.xr-attrs dt {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding-right: 10px;
}

.xr-var-name:hover,
.xr-var-dims:hover,
.xr-var-dtype:hover,
.xr-attrs dt:hover {
  overflow: visible;
  width: auto;
  z-index: 1;
}

.xr-var-attrs,
.xr-var-data,
.xr-index-data {
  display: none;
  background-color: var(--xr-background-color) !important;
  padding-bottom: 5px !important;
}

.xr-var-attrs-in:checked ~ .xr-var-attrs,
.xr-var-data-in:checked ~ .xr-var-data,
.xr-index-data-in:checked ~ .xr-index-data {
  display: block;
}

.xr-var-data > table {
  float: right;
}

.xr-var-name span,
.xr-var-data,
.xr-index-name div,
.xr-index-data,
.xr-attrs {
  padding-left: 25px !important;
}

.xr-attrs,
.xr-var-attrs,
.xr-var-data,
.xr-index-data {
  grid-column: 1 / -1;
}

dl.xr-attrs {
  padding: 0;
  margin: 0;
  display: grid;
  grid-template-columns: 125px auto;
}

.xr-attrs dt,
.xr-attrs dd {
  padding: 0;
  margin: 0;
  float: left;
  padding-right: 10px;
  width: auto;
}

.xr-attrs dt {
  font-weight: normal;
  grid-column: 1;
}

.xr-attrs dt:hover span {
  display: inline-block;
  background: var(--xr-background-color);
  padding-right: 10px;
}

.xr-attrs dd {
  grid-column: 2;
  white-space: pre-wrap;
  word-break: break-all;
}

.xr-icon-database,
.xr-icon-file-text2,
.xr-no-icon {
  display: inline-block;
  vertical-align: middle;
  width: 1em;
  height: 1.5em !important;
  stroke-width: 0;
  stroke: currentColor;
  fill: currentColor;
}
</style><pre class='xr-text-repr-fallback'>&lt;xarray.Dataset&gt;
Dimensions:                 (time: 64)
Coordinates:
  * time                    (time) datetime64[ns] 2020-12-13 ... 2020-12-20T1...
    lat                     (time) float32 -15.2 -15.17 -15.2 ... -24.21 -24.6
    lon                     (time) float32 173.1 172.7 172.5 ... 181.2 181.3
Data variables:
    radius_max_wind         (time) float32 50.0 50.0 50.0 ... 50.0 50.0 50.0
    radius_oci              (time) float32 230.0 190.0 150.0 ... 200.0 200.0
    max_sustained_wind      (time) float32 34.09 36.36 39.77 ... 36.36 34.09
    central_pressure        (time) float32 997.0 996.0 995.0 ... 995.0 997.0
    environmental_pressure  (time) float64 1.005e+03 1.004e+03 ... 1.006e+03
    time_step               (time) float64 3.0 3.0 3.0 3.0 ... 3.0 3.0 3.0 3.0
    basin                   (time) &lt;U2 &#x27;SP&#x27; &#x27;SP&#x27; &#x27;SP&#x27; &#x27;SP&#x27; ... &#x27;SP&#x27; &#x27;SP&#x27; &#x27;SP&#x27;
Attributes:
    max_sustained_wind_unit:  kn
    central_pressure_unit:    mb
    orig_event_flag:          True
    data_provider:            ibtracs_mixed:lat(official_3h),lon(official_3h)...
    category:                 5
    name:                     YASA
    sid:                      2020346S13168
    id_no:                    2020346113168.0</pre><div class='xr-wrap' style='display:none'><div class='xr-header'><div class='xr-obj-type'>xarray.Dataset</div></div><ul class='xr-sections'><li class='xr-section-item'><input id='section-fa84d451-6019-49bf-b29b-df7b04207608' class='xr-section-summary-in' type='checkbox' disabled ><label for='section-fa84d451-6019-49bf-b29b-df7b04207608' class='xr-section-summary'  title='Expand/collapse section'>Dimensions:</label><div class='xr-section-inline-details'><ul class='xr-dim-list'><li><span class='xr-has-index'>time</span>: 64</li></ul></div><div class='xr-section-details'></div></li><li class='xr-section-item'><input id='section-177053a6-c194-4d0d-9318-df16df67e9f6' class='xr-section-summary-in' type='checkbox'  checked><label for='section-177053a6-c194-4d0d-9318-df16df67e9f6' class='xr-section-summary' >Coordinates: <span>(3)</span></label><div class='xr-section-inline-details'></div><div class='xr-section-details'><ul class='xr-var-list'><li class='xr-var-item'><div class='xr-var-name'><span class='xr-has-index'>time</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>datetime64[ns]</div><div class='xr-var-preview xr-preview'>2020-12-13 ... 2020-12-20T18:00:00</div><input id='attrs-f00e3da2-b8af-48fc-be43-d9ba56cc390f' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-f00e3da2-b8af-48fc-be43-d9ba56cc390f' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-bf66c6f5-d9c4-46c9-979c-e50ab0f3203d' class='xr-var-data-in' type='checkbox'><label for='data-bf66c6f5-d9c4-46c9-979c-e50ab0f3203d' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([&#x27;2020-12-13T00:00:00.000000000&#x27;, &#x27;2020-12-13T03:00:00.000000000&#x27;,
       &#x27;2020-12-13T06:00:00.000000000&#x27;, &#x27;2020-12-13T09:00:00.000000000&#x27;,
       &#x27;2020-12-13T12:00:00.000000000&#x27;, &#x27;2020-12-13T15:00:00.000000000&#x27;,
       &#x27;2020-12-13T18:00:00.000000000&#x27;, &#x27;2020-12-13T21:00:00.000000000&#x27;,
       &#x27;2020-12-14T00:00:00.000000000&#x27;, &#x27;2020-12-14T03:00:00.000000000&#x27;,
       &#x27;2020-12-14T06:00:00.000000000&#x27;, &#x27;2020-12-14T09:00:00.000000000&#x27;,
       &#x27;2020-12-14T12:00:00.000000000&#x27;, &#x27;2020-12-14T15:00:00.000000000&#x27;,
       &#x27;2020-12-14T18:00:00.000000000&#x27;, &#x27;2020-12-14T21:00:00.000000000&#x27;,
       &#x27;2020-12-15T00:00:00.000000000&#x27;, &#x27;2020-12-15T03:00:00.000000000&#x27;,
       &#x27;2020-12-15T06:00:00.000000000&#x27;, &#x27;2020-12-15T09:00:00.000000000&#x27;,
       &#x27;2020-12-15T12:00:00.000000000&#x27;, &#x27;2020-12-15T15:00:00.000000000&#x27;,
       &#x27;2020-12-15T18:00:00.000000000&#x27;, &#x27;2020-12-15T21:00:00.000000000&#x27;,
       &#x27;2020-12-16T00:00:00.000000000&#x27;, &#x27;2020-12-16T03:00:00.000000000&#x27;,
       &#x27;2020-12-16T06:00:00.000000000&#x27;, &#x27;2020-12-16T09:00:00.000000000&#x27;,
       &#x27;2020-12-16T12:00:00.000000000&#x27;, &#x27;2020-12-16T15:00:00.000000000&#x27;,
       &#x27;2020-12-16T18:00:00.000000000&#x27;, &#x27;2020-12-16T21:00:00.000000000&#x27;,
       &#x27;2020-12-17T00:00:00.000000000&#x27;, &#x27;2020-12-17T03:00:00.000000000&#x27;,
       &#x27;2020-12-17T06:00:00.000000000&#x27;, &#x27;2020-12-17T07:00:00.000000000&#x27;,
       &#x27;2020-12-17T09:00:00.000000000&#x27;, &#x27;2020-12-17T12:00:00.000000000&#x27;,
       &#x27;2020-12-17T15:00:00.000000000&#x27;, &#x27;2020-12-17T18:00:00.000000000&#x27;,
       &#x27;2020-12-17T21:00:00.000000000&#x27;, &#x27;2020-12-18T00:00:00.000000000&#x27;,
       &#x27;2020-12-18T03:00:00.000000000&#x27;, &#x27;2020-12-18T06:00:00.000000000&#x27;,
       &#x27;2020-12-18T09:00:00.000000000&#x27;, &#x27;2020-12-18T12:00:00.000000000&#x27;,
       &#x27;2020-12-18T15:00:00.000000000&#x27;, &#x27;2020-12-18T18:00:00.000000000&#x27;,
       &#x27;2020-12-18T21:00:00.000000000&#x27;, &#x27;2020-12-19T00:00:00.000000000&#x27;,
       &#x27;2020-12-19T03:00:00.000000000&#x27;, &#x27;2020-12-19T06:00:00.000000000&#x27;,
       &#x27;2020-12-19T09:00:00.000000000&#x27;, &#x27;2020-12-19T12:00:00.000000000&#x27;,
       &#x27;2020-12-19T15:00:00.000000000&#x27;, &#x27;2020-12-19T18:00:00.000000000&#x27;,
       &#x27;2020-12-19T21:00:00.000000000&#x27;, &#x27;2020-12-20T00:00:00.000000000&#x27;,
       &#x27;2020-12-20T03:00:00.000000000&#x27;, &#x27;2020-12-20T06:00:00.000000000&#x27;,
       &#x27;2020-12-20T09:00:00.000000000&#x27;, &#x27;2020-12-20T12:00:00.000000000&#x27;,
       &#x27;2020-12-20T15:00:00.000000000&#x27;, &#x27;2020-12-20T18:00:00.000000000&#x27;],
      dtype=&#x27;datetime64[ns]&#x27;)</pre></div></li><li class='xr-var-item'><div class='xr-var-name'><span>lat</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>float32</div><div class='xr-var-preview xr-preview'>-15.2 -15.17 -15.2 ... -24.21 -24.6</div><input id='attrs-fad8e80e-9681-4eee-9ff0-abde9affbb07' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-fad8e80e-9681-4eee-9ff0-abde9affbb07' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-768e81a9-e47d-497a-88e2-3660a4884eca' class='xr-var-data-in' type='checkbox'><label for='data-768e81a9-e47d-497a-88e2-3660a4884eca' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([-15.2     , -15.172693, -15.2     , -15.319935, -15.5     ,
       -15.71497 , -15.9     , -16.010073, -16.      , -15.81497 ,
       -15.6     , -15.542496, -15.5     , -15.357452, -15.2     ,
       -15.077543, -15.      , -14.992531, -15.      , -14.957386,
       -14.9     , -14.857623, -14.8     , -14.669821, -14.6     ,
       -14.71262 , -14.9     , -15.049695, -15.2     , -15.335211,
       -15.5     , -15.734777, -16.      , -16.236345, -16.5     ,
       -16.6     , -16.9     , -17.2     , -17.552794, -17.9     ,
       -18.15316 , -18.4     , -18.7     , -19.2     , -19.414701,
       -19.5     , -19.652195, -19.9     , -20.3     , -21.      ,
       -21.368101, -21.6     , -22.000177, -22.4     , -22.72992 ,
       -23.      , -23.22991 , -23.4     , -23.507683, -23.6     ,
       -23.712439, -23.9     , -24.212538, -24.6     ], dtype=float32)</pre></div></li><li class='xr-var-item'><div class='xr-var-name'><span>lon</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>float32</div><div class='xr-var-preview xr-preview'>173.1 172.7 172.5 ... 181.2 181.3</div><input id='attrs-6250de74-a8ee-4c94-8371-31a11b47303f' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-6250de74-a8ee-4c94-8371-31a11b47303f' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-99cd374a-1db8-4c0b-994a-8fae0a0b43a3' class='xr-var-data-in' type='checkbox'><label for='data-99cd374a-1db8-4c0b-994a-8fae0a0b43a3' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([173.1    , 172.73749, 172.5    , 172.46246, 172.5    , 172.48   ,
       172.4    , 172.20004, 172.     , 171.91997, 171.9    , 171.88501,
       171.9    , 171.91248, 172.     , 172.22006, 172.5    , 172.77243,
       173.     , 173.09248, 173.2    , 173.49251, 173.8    , 173.9351 ,
       174.1    , 174.46986, 174.9    , 175.22015, 175.6    , 176.17761,
       176.8    , 177.31506, 177.8    , 178.27318, 178.8    , 179.     ,
       179.4    , 180.3    , 180.59036, 180.6    , 180.76508, 181.1    ,
       181.7    , 182.     , 182.16158, 182.2    , 182.2214 , 182.1    ,
       181.8    , 181.7    , 181.64555, 181.7    , 181.942  , 182.2    ,
       182.30264, 182.3    , 182.25252, 182.1    , 181.80748, 181.5    ,
       181.29753, 181.2    , 181.2173 , 181.3    ], dtype=float32)</pre></div></li></ul></div></li><li class='xr-section-item'><input id='section-9460094e-8096-4cee-ab01-6d0ed8672f2a' class='xr-section-summary-in' type='checkbox'  checked><label for='section-9460094e-8096-4cee-ab01-6d0ed8672f2a' class='xr-section-summary' >Data variables: <span>(7)</span></label><div class='xr-section-inline-details'></div><div class='xr-section-details'><ul class='xr-var-list'><li class='xr-var-item'><div class='xr-var-name'><span>radius_max_wind</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>float32</div><div class='xr-var-preview xr-preview'>50.0 50.0 50.0 ... 50.0 50.0 50.0</div><input id='attrs-8b23f27a-ae20-4e06-851a-8cbe82080cc0' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-8b23f27a-ae20-4e06-851a-8cbe82080cc0' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-71e09fd9-46bc-4674-9198-414b24c3a7ce' class='xr-var-data-in' type='checkbox'><label for='data-71e09fd9-46bc-4674-9198-414b24c3a7ce' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([50., 50., 50., 37., 25., 27., 30., 30., 30., 25., 20., 20., 20.,
       20., 20., 16., 12., 12., 12., 12., 12., 13., 15., 17., 20., 17.,
       15., 15., 15., 15., 15., 13., 12.,  8.,  5.,  6., 10., 15., 15.,
       15., 15., 15., 15., 15., 20., 25., 27., 30., 30., 30., 30., 30.,
       30., 30., 30., 30., 40., 50., 50., 50., 50., 50., 50., 50.],
      dtype=float32)</pre></div></li><li class='xr-var-item'><div class='xr-var-name'><span>radius_oci</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>float32</div><div class='xr-var-preview xr-preview'>230.0 190.0 150.0 ... 200.0 200.0</div><input id='attrs-5e4ce216-0fcc-4485-b2c2-61f356be71fd' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-5e4ce216-0fcc-4485-b2c2-61f356be71fd' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-2cfb32c0-9303-4385-ae5b-4746c38db4f3' class='xr-var-data-in' type='checkbox'><label for='data-2cfb32c0-9303-4385-ae5b-4746c38db4f3' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([230., 190., 150., 152., 155., 165., 175., 180., 185., 187., 190.,
       195., 200., 200., 200., 200., 200., 200., 200., 207., 215., 215.,
       215., 215., 215., 210., 205., 195., 185., 185., 185., 180., 175.,
       185., 195., 196., 200., 205., 205., 205., 205., 205., 200., 195.,
       190., 185., 185., 185., 197., 210., 212., 215., 207., 200., 200.,
       200., 207., 215., 207., 200., 200., 200., 200., 200.],
      dtype=float32)</pre></div></li><li class='xr-var-item'><div class='xr-var-name'><span>max_sustained_wind</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>float32</div><div class='xr-var-preview xr-preview'>34.09 36.36 39.77 ... 36.36 34.09</div><input id='attrs-c4f6838c-29a5-4c5c-adf0-2731e16b7855' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-c4f6838c-29a5-4c5c-adf0-2731e16b7855' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-591e8e8d-ecf7-455a-a601-c5023c4c09ed' class='xr-var-data-in' type='checkbox'><label for='data-591e8e8d-ecf7-455a-a601-c5023c4c09ed' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([ 34.090908,  36.363636,  39.772728,  45.454544,  51.136364,
        53.409092,  56.818184,  62.5     ,  68.181816,  73.86364 ,
        79.545456,  79.545456,  79.545456,  81.818184,  85.22727 ,
        87.5     ,  90.90909 ,  96.59091 , 102.27273 , 104.545456,
       107.954544, 115.90909 , 125.      , 130.68182 , 136.36363 ,
       136.36363 , 136.36363 , 136.36363 , 136.36363 , 138.63637 ,
       142.04546 , 138.63637 , 136.36363 , 132.95454 , 130.68182 ,
       130.68182 , 119.318184, 107.954544,  96.59091 ,  85.22727 ,
        81.818184,  79.545456,  79.545456,  85.22727 ,  85.22727 ,
        85.22727 ,  79.545456,  73.86364 ,  73.86364 ,  68.181816,
        64.77273 ,  62.5     ,  59.090908,  56.818184,  56.818184,
        56.818184,  53.409092,  51.136364,  47.727272,  45.454544,
        42.045456,  39.772728,  36.363636,  34.090908], dtype=float32)</pre></div></li><li class='xr-var-item'><div class='xr-var-name'><span>central_pressure</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>float32</div><div class='xr-var-preview xr-preview'>997.0 996.0 995.0 ... 995.0 997.0</div><input id='attrs-2e97f2a6-8c2f-4e9c-a790-79f51d903072' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-2e97f2a6-8c2f-4e9c-a790-79f51d903072' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-d96df96c-3455-4393-a388-d970ea968903' class='xr-var-data-in' type='checkbox'><label for='data-d96df96c-3455-4393-a388-d970ea968903' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([997., 996., 995., 993., 991., 989., 987., 984., 982., 977., 972.,
       972., 972., 969., 967., 966., 966., 959., 953., 949., 946., 939.,
       932., 925., 919., 920., 921., 920., 920., 918., 917., 920., 923.,
       925., 928., 928., 940., 954., 961., 969., 969., 970., 971., 967.,
       965., 964., 968., 972., 973., 978., 979., 980., 982., 985., 984.,
       984., 985., 986., 988., 990., 991., 993., 995., 997.],
      dtype=float32)</pre></div></li><li class='xr-var-item'><div class='xr-var-name'><span>environmental_pressure</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>float64</div><div class='xr-var-preview xr-preview'>1.005e+03 1.004e+03 ... 1.006e+03</div><input id='attrs-9990c1b1-bce7-456c-849c-ec3bf71f8e5d' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-9990c1b1-bce7-456c-849c-ec3bf71f8e5d' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-4bab65b8-1a6e-4970-a493-b41708e95d9b' class='xr-var-data-in' type='checkbox'><label for='data-4bab65b8-1a6e-4970-a493-b41708e95d9b' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([1005., 1004., 1003., 1004., 1005., 1005., 1006., 1006., 1006.,
       1005., 1004., 1004., 1005., 1005., 1006., 1006., 1006., 1004.,
       1003., 1004., 1005., 1004., 1003., 1003., 1003., 1002., 1002.,
       1002., 1003., 1002., 1001., 1001., 1002., 1001., 1001., 1001.,
       1002., 1004., 1004., 1004., 1004., 1004., 1004., 1004., 1004.,
       1005., 1005., 1005., 1005., 1005., 1004., 1004., 1004., 1005.,
       1005., 1005., 1005., 1005., 1004., 1004., 1005., 1006., 1006.,
       1006.])</pre></div></li><li class='xr-var-item'><div class='xr-var-name'><span>time_step</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>float64</div><div class='xr-var-preview xr-preview'>3.0 3.0 3.0 3.0 ... 3.0 3.0 3.0 3.0</div><input id='attrs-f5e4178a-6589-40b2-a5ee-28ecc48ce5b4' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-f5e4178a-6589-40b2-a5ee-28ecc48ce5b4' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-9b097098-6f94-4209-9b7d-495237dcf642' class='xr-var-data-in' type='checkbox'><label for='data-9b097098-6f94-4209-9b7d-495237dcf642' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       1.00000001, 1.99999999, 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        , 3.        ,
       3.        , 3.        , 3.        , 3.        ])</pre></div></li><li class='xr-var-item'><div class='xr-var-name'><span>basin</span></div><div class='xr-var-dims'>(time)</div><div class='xr-var-dtype'>&lt;U2</div><div class='xr-var-preview xr-preview'>&#x27;SP&#x27; &#x27;SP&#x27; &#x27;SP&#x27; ... &#x27;SP&#x27; &#x27;SP&#x27; &#x27;SP&#x27;</div><input id='attrs-75789aa7-39d7-4ace-8246-a0676929cece' class='xr-var-attrs-in' type='checkbox' disabled><label for='attrs-75789aa7-39d7-4ace-8246-a0676929cece' title='Show/Hide attributes'><svg class='icon xr-icon-file-text2'><use xlink:href='#icon-file-text2'></use></svg></label><input id='data-14c25a3c-623e-44d1-9742-b081bf13e74e' class='xr-var-data-in' type='checkbox'><label for='data-14c25a3c-623e-44d1-9742-b081bf13e74e' title='Show/Hide data repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-var-attrs'><dl class='xr-attrs'></dl></div><div class='xr-var-data'><pre>array([&#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;,
       &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;,
       &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;,
       &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;,
       &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;,
       &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;, &#x27;SP&#x27;], dtype=&#x27;&lt;U2&#x27;)</pre></div></li></ul></div></li><li class='xr-section-item'><input id='section-a51ee725-d8db-4cee-b466-665a20f5c64a' class='xr-section-summary-in' type='checkbox'  ><label for='section-a51ee725-d8db-4cee-b466-665a20f5c64a' class='xr-section-summary' >Indexes: <span>(1)</span></label><div class='xr-section-inline-details'></div><div class='xr-section-details'><ul class='xr-var-list'><li class='xr-var-item'><div class='xr-index-name'><div>time</div></div><div class='xr-index-preview'>PandasIndex</div><div></div><input id='index-62f52c75-94cc-4881-8489-ac1a8ec865bd' class='xr-index-data-in' type='checkbox'/><label for='index-62f52c75-94cc-4881-8489-ac1a8ec865bd' title='Show/Hide index repr'><svg class='icon xr-icon-database'><use xlink:href='#icon-database'></use></svg></label><div class='xr-index-data'><pre>PandasIndex(DatetimeIndex([&#x27;2020-12-13 00:00:00&#x27;, &#x27;2020-12-13 03:00:00&#x27;,
               &#x27;2020-12-13 06:00:00&#x27;, &#x27;2020-12-13 09:00:00&#x27;,
               &#x27;2020-12-13 12:00:00&#x27;, &#x27;2020-12-13 15:00:00&#x27;,
               &#x27;2020-12-13 18:00:00&#x27;, &#x27;2020-12-13 21:00:00&#x27;,
               &#x27;2020-12-14 00:00:00&#x27;, &#x27;2020-12-14 03:00:00&#x27;,
               &#x27;2020-12-14 06:00:00&#x27;, &#x27;2020-12-14 09:00:00&#x27;,
               &#x27;2020-12-14 12:00:00&#x27;, &#x27;2020-12-14 15:00:00&#x27;,
               &#x27;2020-12-14 18:00:00&#x27;, &#x27;2020-12-14 21:00:00&#x27;,
               &#x27;2020-12-15 00:00:00&#x27;, &#x27;2020-12-15 03:00:00&#x27;,
               &#x27;2020-12-15 06:00:00&#x27;, &#x27;2020-12-15 09:00:00&#x27;,
               &#x27;2020-12-15 12:00:00&#x27;, &#x27;2020-12-15 15:00:00&#x27;,
               &#x27;2020-12-15 18:00:00&#x27;, &#x27;2020-12-15 21:00:00&#x27;,
               &#x27;2020-12-16 00:00:00&#x27;, &#x27;2020-12-16 03:00:00&#x27;,
               &#x27;2020-12-16 06:00:00&#x27;, &#x27;2020-12-16 09:00:00&#x27;,
               &#x27;2020-12-16 12:00:00&#x27;, &#x27;2020-12-16 15:00:00&#x27;,
               &#x27;2020-12-16 18:00:00&#x27;, &#x27;2020-12-16 21:00:00&#x27;,
               &#x27;2020-12-17 00:00:00&#x27;, &#x27;2020-12-17 03:00:00&#x27;,
               &#x27;2020-12-17 06:00:00&#x27;, &#x27;2020-12-17 07:00:00&#x27;,
               &#x27;2020-12-17 09:00:00&#x27;, &#x27;2020-12-17 12:00:00&#x27;,
               &#x27;2020-12-17 15:00:00&#x27;, &#x27;2020-12-17 18:00:00&#x27;,
               &#x27;2020-12-17 21:00:00&#x27;, &#x27;2020-12-18 00:00:00&#x27;,
               &#x27;2020-12-18 03:00:00&#x27;, &#x27;2020-12-18 06:00:00&#x27;,
               &#x27;2020-12-18 09:00:00&#x27;, &#x27;2020-12-18 12:00:00&#x27;,
               &#x27;2020-12-18 15:00:00&#x27;, &#x27;2020-12-18 18:00:00&#x27;,
               &#x27;2020-12-18 21:00:00&#x27;, &#x27;2020-12-19 00:00:00&#x27;,
               &#x27;2020-12-19 03:00:00&#x27;, &#x27;2020-12-19 06:00:00&#x27;,
               &#x27;2020-12-19 09:00:00&#x27;, &#x27;2020-12-19 12:00:00&#x27;,
               &#x27;2020-12-19 15:00:00&#x27;, &#x27;2020-12-19 18:00:00&#x27;,
               &#x27;2020-12-19 21:00:00&#x27;, &#x27;2020-12-20 00:00:00&#x27;,
               &#x27;2020-12-20 03:00:00&#x27;, &#x27;2020-12-20 06:00:00&#x27;,
               &#x27;2020-12-20 09:00:00&#x27;, &#x27;2020-12-20 12:00:00&#x27;,
               &#x27;2020-12-20 15:00:00&#x27;, &#x27;2020-12-20 18:00:00&#x27;],
              dtype=&#x27;datetime64[ns]&#x27;, name=&#x27;time&#x27;, freq=None))</pre></div></li></ul></div></li><li class='xr-section-item'><input id='section-ed512e21-1060-4a5a-b392-0b100ccc8510' class='xr-section-summary-in' type='checkbox'  checked><label for='section-ed512e21-1060-4a5a-b392-0b100ccc8510' class='xr-section-summary' >Attributes: <span>(8)</span></label><div class='xr-section-inline-details'></div><div class='xr-section-details'><dl class='xr-attrs'><dt><span>max_sustained_wind_unit :</span></dt><dd>kn</dd><dt><span>central_pressure_unit :</span></dt><dd>mb</dd><dt><span>orig_event_flag :</span></dt><dd>True</dd><dt><span>data_provider :</span></dt><dd>ibtracs_mixed:lat(official_3h),lon(official_3h),wind(official_3h),pres(official_3h),rmw(usa),poci(usa),roci(usa)</dd><dt><span>category :</span></dt><dd>5</dd><dt><span>name :</span></dt><dd>YASA</dd><dt><span>sid :</span></dt><dd>2020346S13168</dd><dt><span>id_no :</span></dt><dd>2020346113168.0</dd></dl></div></li></ul></div></div>




```python
# Function to add interpolation points
def add_interpolation_points(data, num_points_between):
    new_x_list = []
    for i in range(len(data) - 1):
        start_point, end_point = data[i], data[i + 1]
        interp_x = list(np.linspace(start_point, end_point, num_points_between + 2))
        if i == 0:
            new_x_list.append(interp_x)
        elif i == (len(data) - 1):
            new_x_list.append(interp_x)
        else:
            new_x_list.append(interp_x[1:])

    new_x = np.concatenate(new_x_list)

    return new_x

```


```python
# Example data
w = max_sustained_wind_array.copy()
t = time_array.copy()

# Define the number of points to add between each pair of data points
num_points_between = 2

# Add interpolation points
new_w = add_interpolation_points(w, num_points_between)

# Convert to seconds
timestamps = np.array([date.astype('datetime64[s]').astype('int64') for date in t])
new_t =  add_interpolation_points(timestamps, num_points_between)
# Back to datetime format
new_dates = [np.datetime64(int(ts), 's') for ts in new_t]
```


```python
# Plotting the original and interpolated data
plt.figure(figsize=(8, 6))
plt.plot(timestamps, w, 'rs', alpha=0.5, label='Original Data')
plt.plot(new_t, new_w, 'o', alpha=0.4 ,label='Interpolated Data')
plt.xlabel('Time [s]')
plt.ylabel('Windspeed [kn]')
plt.title('Interpolation between every pair of data points')
plt.legend()
plt.show()
```



![png](01.2_windfields_add_interpolation_points_files/01.2_windfields_add_interpolation_points_16_0.png)




```python
# Interpolate every important data
w = max_sustained_wind_array.copy()
t = time_array.copy()
t_step = time_step_array.copy()
lat = lat_array.copy()
lon = lon_array.copy()
cp = central_pressure_array.copy()
ep = environmental_pressure_array.copy()
rmax = r_max_wind_array.copy()
roci = r_oci_array.copy()

# Define the number of points to add between each pair of data points
num_points_between = 2

# Add interpolation points to regulat variables
new_w = add_interpolation_points(w, num_points_between)
new_t_step = add_interpolation_points(t_step, num_points_between)
new_lat = add_interpolation_points(lat, num_points_between)
new_lon = add_interpolation_points(lon, num_points_between)
new_cp = add_interpolation_points(cp, num_points_between)
new_ep = add_interpolation_points(ep, num_points_between)
new_rmax = add_interpolation_points(rmax, num_points_between)
new_roci = add_interpolation_points(roci, num_points_between)

# Add interpolation points to time variables
timestamps = np.array([date.astype('datetime64[s]').astype('int64') for date in t])# Convert to seconds
new_t =  add_interpolation_points(timestamps, num_points_between)
new_t = [np.datetime64(int(ts), 's') for ts in new_t]# Back to datetime format
```


```python
# Define dataframe
df_t = pd.DataFrame({
    'MeanWind': new_w,
    'PressureOCI': new_ep,
    'Pressure': new_cp,
    'Latitude': new_lat,
    'Longitude': new_lon,
    'RadiusMaxWinds': new_rmax,
    'RadiusOCI': new_roci,
    'time_step': new_t_step,
    'basin': np.array([np.array(track_xarray.basin)[0]] * len(new_t)),
    'forecast_time': new_t,
    'Category': track_xarray.category
})
```


```python
# Create xarray
def adjust_tracks(forecast_df):
    track = xr.Dataset(
        data_vars={
            'max_sustained_wind': ('time', np.array(forecast_df.MeanWind.values, dtype='float32')), #0.514444 --> kn to m/s
            'environmental_pressure': ('time', forecast_df.PressureOCI.values), # I assume its enviromental pressure
            'central_pressure': ('time',forecast_df.Pressure.values),
            'lat': ('time',forecast_df.Latitude.values),
            'lon': ('time', forecast_df.Longitude.values),
            'radius_max_wind': ('time', forecast_df.RadiusMaxWinds.values),
            'radius_oci': ('time',forecast_df.RadiusOCI.values), # Works even if there is a bunch of nans. Doesnt change the windspeed values
            'time_step': ('time', forecast_df.time_step),
            'basin': ('time', np.array(forecast_df.basin, dtype='<U2'))
        },
        coords={
            'time': forecast_df.forecast_time.values,
        },
        attrs={
            'max_sustained_wind_unit': 'kn',
            'central_pressure_unit': 'mb',
            'name': name,
            'sid' : custom_sid,
            'orig_event_flag': True,
            'data_provider': 'Custom',
            'id_no' : custom_idno,
            'category': int(max(forecast_df.Category.iloc)),
        }
    )
    track = track.set_coords(['lat', 'lon'])
    return track
```


```python
# Define a custom ider
custom_idno = track_xarray.id_no
custom_sid = str(custom_idno)
name = track_xarray.name + ' interpolated'

# Define it
track = TCTracks()
track.data = [adjust_tracks(df_t)]

# Define tropcycloneclass
cent_all = Centroids.from_geodataframe(gdf_all)
cent_all.set_dist_coast(precomputed=True)
tc_all = TropCyclone.from_tracks(
    track, centroids=cent_all, store_windfields=True, intensity_thres=0
)

# Create grid-level windfield
df_windfield_yasa_interpolated = windfield_to_grid(tc=tc_all, tracks=track, grids=gdf_all)
```

    2024-02-29 16:58:59,779 - climada.hazard.centroids.centr - WARNING - Centroids.from_geodataframe has been deprecated and will be removed in a future version. Use ther default constructor instead.



```python
# # Fix 0 windspeed values
# df_windfield_mod = df_windfield_yasa_interpolated.copy()
# df_windfield_mod = df_windfield_mod.drop('geometry', axis=1)
# typhoons = df_windfield_mod.typhoon_name.unique()

# buffer = 0.1
# df_windfield_fix = pd.DataFrame()
# for typhoon in typhoons:
#     df_aux = gpd.GeoDataFrame(df_windfield_mod[df_windfield_mod.typhoon_name==typhoon].merge(
#         gdf_all,
#         left_on='grid_point_id',
#         right_on='id'), geometry='geometry')
#     # compute mean
#     df_aux['wind_speed'] = df_aux.apply(lambda row: calculate_mean_for_neighbors(row.name, df_aux, buffer_size=buffer), axis=1)
#     # back to df
#     df_aux = pd.DataFrame(df_aux)
#     df_windfield_fix = pd.concat([df_windfield_fix, df_aux])
```


```python
# Track path
tc_track = track.get_track()
points = gpd.points_from_xy(tc_track.lon, tc_track.lat)
track_points = gpd.GeoDataFrame(geometry=points)
tc_track_line = LineString(points)
track_line = gpd.GeoDataFrame(geometry=[tc_track_line])

# Plot intensity
name='YASA + interpolation'
fig, ax = plt.subplots(1,1, figsize=(5,5))
geo_windfield = gpd.GeoDataFrame(df_windfield_yasa_interpolated)
geo_windfield.plot(column='wind_speed', cmap='Reds', linewidth=0.2, edgecolor='0.3', ax=ax, legend=True)
track_line.plot(ax=ax, color='k', linewidth=1, label='Typhoon track')
#track_points.plot(ax=ax, color='k', linewidth=0.1, alpha=0.4, label='Typhoon track datapoints')
ax.set_title('Yasa interpolated track \nWindspeed [m/s]')
ax.set_xlim(176.5, 182)
ax.set_ylim(-20, -12)
ax.set_xticks([])
ax.set_yticks([])
plt.show()
```



![png](01.2_windfields_add_interpolation_points_files/01.2_windfields_add_interpolation_points_22_0.png)



## Automation of interpolation

### Functions


```python
# Wind to grid
def windfield_to_grid(tc, tracks, grids):
    df_windfield = pd.DataFrame()

    for intensity_sparse, event_id in zip(tc.intensity, tc.event_name):
        # Get the windfield
        windfield = intensity_sparse.toarray().flatten()
        npoints = len(windfield)
        # Get the track distance
        tc_track = tracks.get_track(track_name=event_id)
        points = gpd.points_from_xy(tc_track.lon, tc_track.lat)
        tc_track_line = LineString(points)
        DEG_TO_KM = 111.1
        tc_track_distance = grids["geometry"].apply(
            lambda point: point.distance(tc_track_line) * DEG_TO_KM
        )
        # Add to DF
        df_to_add = pd.DataFrame(
            dict(
                typhoon_name=[tc_track.name] * npoints,
                track_id=[event_id] * npoints,
                grid_point_id=grids["id"],
                wind_speed=windfield,
                track_distance=tc_track_distance,
                geometry = grids.geometry
            )
        )
        df_windfield = pd.concat([df_windfield, df_to_add], ignore_index=True)
    return df_windfield

# Define a function to calculate mean values for neighboring cells
def calculate_mean_for_neighbors(idx, gdf, buffer_size):
    row = gdf.iloc[idx]
    if row['wind_speed'] == 0:  # Check if wind_speed is 0
        buffered = row['geometry'].buffer(buffer_size)  # Adjust buffer size as needed

        # Find neighboring geometries that intersect with the buffer, excluding the current geometry
        neighbors = gdf[~gdf.geometry.equals(row['geometry']) & gdf.geometry.intersects(buffered)]

        if not neighbors.empty:
            # drop rows with 0 windspeed vals (we dont want to compute the mean while considering these cells)
            neighbors = neighbors[neighbors['wind_speed'] !=0]
            if len(neighbors) !=0:
                mean_val = neighbors['wind_speed'].mean()
            else:
                mean_val = 0
            return mean_val
    return row['wind_speed']  # Return the original value if no neighbors or wind_speed != 0

# Create xarray
def adjust_tracks(forecast_df):
    track = xr.Dataset(
        data_vars={
            'max_sustained_wind': ('time', np.array(forecast_df.MeanWind.values, dtype='float32')), #0.514444 --> kn to m/s
            'environmental_pressure': ('time', forecast_df.PressureOCI.values), # I assume its enviromental pressure
            'central_pressure': ('time',forecast_df.Pressure.values),
            'lat': ('time',forecast_df.Latitude.values),
            'lon': ('time', forecast_df.Longitude.values),
            'radius_max_wind': ('time', forecast_df.RadiusMaxWinds.values),
            'radius_oci': ('time',forecast_df.RadiusOCI.values), # Works even if there is a bunch of nans. Doesnt change the windspeed values
            'time_step': ('time', forecast_df.time_step),
            'basin': ('time', np.array(forecast_df.basin, dtype='<U2'))
        },
        coords={
            'time': forecast_df.forecast_time.values,
        },
        attrs={
            'max_sustained_wind_unit': 'kn',
            'central_pressure_unit': 'mb',
            'name': name,
            'sid' : custom_sid,
            'orig_event_flag': True,
            'data_provider': 'Custom',
            'id_no' : custom_idno,
            'category': int(max(forecast_df.Category.iloc)),
        }
    )
    track = track.set_coords(['lat', 'lon'])
    return track

# Function to add interpolation points
def add_interpolation_points(data, num_points_between):
    new_x_list = []
    for i in range(len(data) - 1):
        start_point, end_point = data[i], data[i + 1]
        interp_x = list(np.linspace(start_point, end_point, num_points_between + 2))
        if i == 0:
            new_x_list.append(interp_x)
        elif i == (len(data) - 1):
            new_x_list.append(interp_x)
        else:
            new_x_list.append(interp_x[1:])

    new_x = np.concatenate(new_x_list)

    return new_x
```

### The process


```python
tracks = TCTracks()
for i in range(len(tc_tracks.get_track())):
    # Define relevant features
    track_xarray = tc_tracks.get_track()[i]
    time_array = np.array(track_xarray.time)
    time_step_array = np.array(track_xarray.time_step)
    lat_array = np.array(track_xarray.lat)
    lon_array = np.array(track_xarray.lon)
    max_sustained_wind_array = np.array(track_xarray.max_sustained_wind)
    central_pressure_array = np.array(track_xarray.central_pressure)
    environmental_pressure_array = np.array(track_xarray.environmental_pressure)
    r_max_wind_array = np.array(track_xarray.radius_max_wind)
    r_oci_array = np.array(track_xarray.radius_oci)

    # Define new variables
    # Interpolate every important data
    w = max_sustained_wind_array.copy()
    t = time_array.copy()
    t_step = time_step_array.copy()
    lat = lat_array.copy()
    lon = lon_array.copy()
    cp = central_pressure_array.copy()
    ep = environmental_pressure_array.copy()
    rmax = r_max_wind_array.copy()
    roci = r_oci_array.copy()

    # Define the number of points to add between each pair of data points
    num_points_between = 2

    # Add interpolation points to regulat variables
    new_w = add_interpolation_points(w, num_points_between)
    new_t_step = add_interpolation_points(t_step, num_points_between)
    new_lat = add_interpolation_points(lat, num_points_between)
    new_lon = add_interpolation_points(lon, num_points_between)
    new_cp = add_interpolation_points(cp, num_points_between)
    new_ep = add_interpolation_points(ep, num_points_between)
    new_rmax = add_interpolation_points(rmax, num_points_between)
    new_roci = add_interpolation_points(roci, num_points_between)

    # Add interpolation points to time variables
    timestamps = np.array([date.astype('datetime64[s]').astype('int64') for date in t])# Convert to seconds
    new_t =  add_interpolation_points(timestamps, num_points_between)
    new_t = [np.datetime64(int(ts), 's') for ts in new_t]# Back to datetime format

    # Define dataframe
    df_t = pd.DataFrame({
        'MeanWind': new_w,
        'PressureOCI': new_ep,
        'Pressure': new_cp,
        'Latitude': new_lat,
        'Longitude': new_lon,
        'RadiusMaxWinds': new_rmax,
        'RadiusOCI': new_roci,
        'time_step': new_t_step,
        'basin': np.array([np.array(track_xarray.basin)[0]] * len(new_t)),
        'forecast_time': new_t,
        'Category': track_xarray.category
    })

    # Define a custom id
    custom_idno = track_xarray.id_no
    custom_sid = str(custom_idno)
    name = track_xarray.name + ' interpolated'

    # Define track as climada likes it
    track = TCTracks()
    track.data = [adjust_tracks(df_t)]

    # Tracks modified
    tracks.append(track.get_track())
```


```python
# Define tropcycloneclass
cent_all = Centroids.from_geodataframe(gdf_all)
cent_all.set_dist_coast(precomputed=True)

tc_all = TropCyclone.from_tracks(
    tracks, centroids=cent_all, store_windfields=True, intensity_thres=0
)

# Create grid-level windfield
df_windfield_interpolated = windfield_to_grid(tc=tc_all, tracks=tracks, grids=gdf_all)

# # Fix 0 windspeed values
# df_windfield_mod = df_windfield_interpolated.copy()
# df_windfield_mod = df_windfield_mod.drop('geometry', axis=1)
# typhoons = df_windfield_mod.typhoon_name.unique()

# buffer = 0.1
# df_windfield_interpolated_fix = pd.DataFrame()
# for typhoon in typhoons:
#     df_aux = gpd.GeoDataFrame(df_windfield_mod[df_windfield_mod.typhoon_name==typhoon].merge(
#         gdf_all,
#         left_on='grid_point_id',
#         right_on='id'), geometry='geometry')
#     # compute mean
#     df_aux['wind_speed'] = df_aux.apply(lambda row: calculate_mean_for_neighbors(row.name, df_aux, buffer_size=buffer), axis=1)
#     # back to df
#     df_aux = pd.DataFrame(df_aux)
#     df_windfield_interpolated_fix = pd.concat([df_windfield_interpolated_fix, df_aux])
df_windfield_interpolated_fix = df_windfield_interpolated.copy()
```

    2024-01-17 17:39:04,366 - climada.hazard.centroids.centr - WARNING - Centroids.from_geodataframe has been deprecated and will be removed in a future version. Use ther default constructor instead.



```python
fig, ax = plt.subplots(1,3, figsize=(10,4))
ax = ax.flatten()

for i in range(3):
    # Track path
    tc_track = tracks.get_track()[-3:][i]
    points = gpd.points_from_xy(tc_track.lon, tc_track.lat)
    track_points = gpd.GeoDataFrame(geometry=points)
    tc_track_line = LineString(points)
    track_line = gpd.GeoDataFrame(geometry=[tc_track_line])

    # Plot intensity
    name = tc_track.name
    geo_windfield = gpd.GeoDataFrame(df_windfield_interpolated_fix[df_windfield_interpolated_fix.typhoon_name == name])
    geo_windfield.plot(column='wind_speed', cmap='Reds', linewidth=0.2, edgecolor='0.3', ax=ax[i], legend=True)
    track_line.plot(ax=ax[i], color='k', linewidth=1, label='Typhoon track')

    ax[i].axis('off')
    ax[i].set_xlim(176, 182)
    ax[i].set_ylim(-20, -12)
    ax[i].set_title(name)

plt.tight_layout()
plt.show()
```



![png](01.2_windfields_add_interpolation_points_files/01.2_windfields_add_interpolation_points_29_0.png)



## Save everything


```python
df_windfield_interpolated_fix_overlap = df_windfield_interpolated_fix[df_windfield_interpolated_fix.grid_point_id.isin(gdf.id)]
df_windfield_interpolated_fix_overlap['typhoon_name'] = df_windfield_interpolated_fix_overlap.typhoon_name.str.split().str.get(0)
```


```python
df_windfield_interpolated_fix_overlap.to_csv(input_dir / "01_windfield/windfield_data_fji_new_fixed_interpolated_overlap.csv", index = False)
```
