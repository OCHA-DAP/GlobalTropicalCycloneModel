```python
from pathlib import Path
import os

from climada.hazard import Centroids, TCTracks, TropCyclone
from shapely.geometry import LineString
import geopandas as gpd
import numpy as np
import pandas as pd
import xarray as xr
import matplotlib.pyplot as plt
```


```python
DEG_TO_KM = 111.1  # Convert 1 degree to km
input_dir = Path(os.getenv("STORM_DATA_DIR")) / "analysis_fji/02_model_features"
```

## Get typhoon data


```python
# Import list of typhoons to a dataframe
typhoons_df = pd.read_csv(input_dir / "01_windfield/typhoons.csv")
```


```python
housing_path_in = input_dir / '02_housing_damage/input'
df_housing = pd.read_csv(housing_path_in / 'fji_impact_data/processed_house_impact.csv')
```


```python
cyclones = df_housing['Cyclone Name'].unique()
intersection = typhoons_df[typhoons_df['typhoon_name'].isin(cyclones)].drop_duplicates(keep='last', subset = ['typhoon_name'])
```


```python
# Download NECESARY tracks
sel_ibtracs = []
for track in intersection.typhoon_id:
    sel_ibtracs.append(TCTracks.from_ibtracs_netcdf(storm_id=track))
```

    2024-01-03 17:58:04,949 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-01-03 17:58:07,822 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-01-03 17:58:10,894 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-01-03 17:58:13,903 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-01-03 17:58:16,922 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-01-03 17:58:19,918 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-01-03 17:58:23,058 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-01-03 17:58:26,059 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-01-03 17:58:29,187 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.


## Synthetic tracks


```python
intersection
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>typhoon_id</th>
      <th>typhoon_name</th>
      <th>typhoon_year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>659</th>
      <td>659</td>
      <td>2010069S12188</td>
      <td>Tomas</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>678</th>
      <td>678</td>
      <td>2012346S14180</td>
      <td>Evan</td>
      <td>2012</td>
    </tr>
    <tr>
      <th>715</th>
      <td>715</td>
      <td>2016041S14170</td>
      <td>Winston</td>
      <td>2016</td>
    </tr>
    <tr>
      <th>732</th>
      <td>732</td>
      <td>2018038S15172</td>
      <td>Gita</td>
      <td>2018</td>
    </tr>
    <tr>
      <th>749</th>
      <td>749</td>
      <td>2019359S08175</td>
      <td>Sarai</td>
      <td>2019</td>
    </tr>
    <tr>
      <th>751</th>
      <td>751</td>
      <td>2020015S12170</td>
      <td>Tino</td>
      <td>2020</td>
    </tr>
    <tr>
      <th>759</th>
      <td>759</td>
      <td>2020092S09155</td>
      <td>Harold</td>
      <td>2020</td>
    </tr>
    <tr>
      <th>761</th>
      <td>761</td>
      <td>2020346S13168</td>
      <td>Yasa</td>
      <td>2020</td>
    </tr>
    <tr>
      <th>769</th>
      <td>769</td>
      <td>2021029S16171</td>
      <td>Ana</td>
      <td>2021</td>
    </tr>
  </tbody>
</table>
</div>




```python
winston_track = TCTracks.from_ibtracs_netcdf(storm_id='2016041S14170')
yasa_track = TCTracks.from_ibtracs_netcdf(storm_id='2020346S13168')
```

    2024-01-04 00:52:37,322 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.
    2024-01-04 00:52:40,301 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.



```python
# Probabilistic events
yasa_track.equal_timestep()
yasa_track.calc_perturbed_trajectories(nb_synth_tracks=5)
ax = yasa_track.plot()
ax.set_title('YASA synthetic tracks', size=20)
plt.plot()
```




    []





![png](06.0_ensembles_example_files/06.0_ensembles_example_10_1.png)



### Define some functions


```python
def windfield_to_grid(tc, tracks, grids):
    df_windfield = pd.DataFrame()

    for intensity_sparse, event_id in zip(tc.intensity, tc.event_name):
        # Get the windfield
        windfield = intensity_sparse.toarray().flatten()
        npoints = len(windfield)
        # Get the track distance
        tc_track = tracks.get_track(track_name=event_id)
        points = gpd.points_from_xy(tc_track.lon, tc_track.lat)
        tc_track_line = LineString(points)
        DEG_TO_KM = 111.1
        tc_track_distance = grids["geometry"].apply(
            lambda point: point.distance(tc_track_line) * DEG_TO_KM
        )
        # Add to DF
        df_to_add = pd.DataFrame(
            dict(
                typhoon_name=[tc_track.name] * npoints,
                track_id=[event_id] * npoints,
                grid_point_id=grids["id"],
                wind_speed=windfield,
                track_distance=tc_track_distance,
                geometry = grids.geometry
            )
        )
        df_windfield = pd.concat([df_windfield, df_to_add], ignore_index=True)
    return df_windfield

# Define a function to calculate mean values for neighboring cells
def calculate_mean_for_neighbors(idx, gdf, buffer_size):
    row = gdf.iloc[idx]
    if row['wind_speed'] == 0:  # Check if wind_speed is 0
        buffered = row['geometry'].buffer(buffer_size)  # Adjust buffer size as needed

        # Find neighboring geometries that intersect with the buffer, excluding the current geometry
        neighbors = gdf[~gdf.geometry.equals(row['geometry']) & gdf.geometry.intersects(buffered)]

        if not neighbors.empty:
            # drop rows with 0 windspeed vals (we dont want to compute the mean while considering these cells)
            neighbors = neighbors[neighbors['wind_speed'] !=0]
            if len(neighbors) !=0:
                mean_val = neighbors['wind_speed'].mean()
            else:
                mean_val = 0
            return mean_val
    return row['wind_speed']  # Return the original value if no neighbors or wind_speed != 0

# Function to add interpolation points
def add_interpolation_points(data, num_points_between):
    new_x_list = []
    for i in range(len(data) - 1):
        start_point, end_point = data[i], data[i + 1]
        interp_x = list(np.linspace(start_point, end_point, num_points_between + 2))
        if i == 0:
            new_x_list.append(interp_x)
        elif i == (len(data) - 1):
            new_x_list.append(interp_x)
        else:
            new_x_list.append(interp_x[1:])

    new_x = np.concatenate(new_x_list)

    return new_x

# Create xarray
def adjust_tracks(forecast_df):
    track = xr.Dataset(
        data_vars={
            'max_sustained_wind': ('time', np.array(forecast_df.MeanWind.values, dtype='float32')), #0.514444 --> kn to m/s
            'environmental_pressure': ('time', forecast_df.PressureOCI.values), # I assume its enviromental pressure
            'central_pressure': ('time',forecast_df.Pressure.values),
            'lat': ('time',forecast_df.Latitude.values),
            'lon': ('time', forecast_df.Longitude.values),
            'radius_max_wind': ('time', forecast_df.RadiusMaxWinds.values),
            'radius_oci': ('time',forecast_df.RadiusOCI.values), # Works even if there is a bunch of nans. Doesnt change the windspeed values
            'time_step': ('time', forecast_df.time_step),
            'basin': ('time', np.array(forecast_df.basin, dtype='<U2'))
        },
        coords={
            'time': forecast_df.forecast_time.values,
        },
        attrs={
            'max_sustained_wind_unit': 'kn',
            'central_pressure_unit': 'mb',
            'name': name,
            'sid' : custom_sid,
            'orig_event_flag': True,
            'data_provider': 'Custom',
            'id_no' : custom_idno,
            'category': int(max(forecast_df.Category.iloc)),
        }
    )
    track = track.set_coords(['lat', 'lon'])
    return track
```

## To grid


```python
# Just grid-land overlap
filepath = (
    input_dir
    / "02_housing_damage/output/fji_0.1_degree_grid_centroids_land_overlap_new.gpkg"
)
gdf = gpd.read_file(filepath)
# Include oceans
filepath_complete = (
    input_dir
    / "02_housing_damage/output/fji_0.1_degree_grid_centroids_new.gpkg"
)
gdf_all = gpd.read_file(filepath_complete)

# Centroids
cent = Centroids.from_geodataframe(gdf) # grid-land overlap
cent_all = Centroids.from_geodataframe(gdf_all) # include oceans
```

    2024-01-04 00:54:45,608 - climada.hazard.centroids.centr - WARNING - Centroids.from_geodataframe has been deprecated and will be removed in a future version. Use ther default constructor instead.
    2024-01-04 00:54:45,611 - climada.hazard.centroids.centr - WARNING - Centroids.from_geodataframe has been deprecated and will be removed in a future version. Use ther default constructor instead.


add interpolation points


```python
tracks = TCTracks()
for i in range(len(tc_tracks.get_track())):
    # Define relevant features
    track_xarray = tc_tracks.get_track()[i]
    time_array = np.array(track_xarray.time)
    time_step_array = np.array(track_xarray.time_step)
    lat_array = np.array(track_xarray.lat)
    lon_array = np.array(track_xarray.lon)
    max_sustained_wind_array = np.array(track_xarray.max_sustained_wind)
    central_pressure_array = np.array(track_xarray.central_pressure)
    environmental_pressure_array = np.array(track_xarray.environmental_pressure)
    r_max_wind_array = np.array(track_xarray.radius_max_wind)
    r_oci_array = np.array(track_xarray.radius_oci)

    # Define new variables
    # Interpolate every important data
    w = max_sustained_wind_array.copy()
    t = time_array.copy()
    t_step = time_step_array.copy()
    lat = lat_array.copy()
    lon = lon_array.copy()
    cp = central_pressure_array.copy()
    ep = environmental_pressure_array.copy()
    rmax = r_max_wind_array.copy()
    roci = r_oci_array.copy()

    # Define the number of points to add between each pair of data points
    num_points_between = 2

    # Add interpolation points to regulat variables
    new_w = add_interpolation_points(w, num_points_between)
    new_t_step = add_interpolation_points(t_step, num_points_between)
    new_lat = add_interpolation_points(lat, num_points_between)
    new_lon = add_interpolation_points(lon, num_points_between)
    new_cp = add_interpolation_points(cp, num_points_between)
    new_ep = add_interpolation_points(ep, num_points_between)
    new_rmax = add_interpolation_points(rmax, num_points_between)
    new_roci = add_interpolation_points(roci, num_points_between)

    # Add interpolation points to time variables
    timestamps = np.array([date.astype('datetime64[s]').astype('int64') for date in t])# Convert to seconds
    new_t =  add_interpolation_points(timestamps, num_points_between)
    new_t = [np.datetime64(int(ts), 's') for ts in new_t]# Back to datetime format

    # Define dataframe
    df_t = pd.DataFrame({
        'MeanWind': new_w,
        'PressureOCI': new_ep,
        'Pressure': new_cp,
        'Latitude': new_lat,
        'Longitude': new_lon,
        'RadiusMaxWinds': new_rmax,
        'RadiusOCI': new_roci,
        'time_step': new_t_step,
        'basin': np.array([np.array(track_xarray.basin)[0]] * len(new_t)),
        'forecast_time': new_t,
        'Category': track_xarray.category
    })

    # Define a custom id
    custom_idno = track_xarray.id_no
    custom_sid = track_xarray.sid
    name = track_xarray.name# + ' interpolated'

    # Define track as climada likes it
    track = TCTracks()
    track.data = [adjust_tracks(df_t)]

    # Tracks modified
    tracks.append(track.get_track())
```


```python
tc_all = TropCyclone.from_tracks(
    tracks, centroids=cent_all, store_windfields=True, intensity_thres=0
)

# Create grid-level windfield
df_windfield_interpolated = windfield_to_grid(tc=tc_all, tracks=tracks, grids=gdf_all)

# Overlap
df_windfield_interpolated_overlap = df_windfield_interpolated[df_windfield_interpolated.grid_point_id.isin(gdf.id)]
```


```python
tc_all.event_name
```




    ['2020346S13168',
     '2020346S13168_gen1',
     '2020346S13168_gen2',
     '2020346S13168_gen3',
     '2020346S13168_gen4',
     '2020346S13168_gen5']




```python
df_windfield = pd.DataFrame()

for intensity_sparse, event_id in zip(tc_all.intensity, tc_all.event_name):
    # Get the windfield
    windfield = intensity_sparse.toarray().flatten()
    npoints = len(windfield)
    typhoon_info = typhoons_df[typhoons_df["typhoon_id"] == event_id]
    # Get the track distance
    tc_track = yasa_track.get_track(track_name=event_id)
    points = gpd.points_from_xy(tc_track.lon, tc_track.lat)
    tc_track_line = LineString(points)
    # TODO: Not sure that curvature is taken into account in this
    # calculation, i.e. might be missing cos(lat) term. Since we're
    # close to the equator in this case it doesn't matter.
    tc_track_distance = gdf_all["geometry"].apply(
        lambda point: point.distance(tc_track_line) * DEG_TO_KM
    )
    # Add to DF
    df_to_add = pd.DataFrame(
        dict(
            typhoon_id=[event_id] * npoints,
            # typhoon_name=[typhoon_info["typhoon_name"].values[0]] * npoints,
            # typhoon_year=[typhoon_info["typhoon_year"].values[0]] * npoints,
            grid_point_id=gdf_all["id"],
            wind_speed=windfield,
            track_distance=tc_track_distance,
            geometry = gdf_all.geometry
        )
    )
    df_windfield = pd.concat([df_windfield, df_to_add], ignore_index=True)
df_windfield
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>typhoon_id</th>
      <th>grid_point_id</th>
      <th>wind_speed</th>
      <th>track_distance</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2020346S13168</td>
      <td>1</td>
      <td>0.000000</td>
      <td>364.449886</td>
      <td>POINT (176.55000 -12.05000)</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2020346S13168</td>
      <td>2</td>
      <td>0.000000</td>
      <td>354.400360</td>
      <td>POINT (176.55000 -12.15000)</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2020346S13168</td>
      <td>3</td>
      <td>0.000000</td>
      <td>343.662272</td>
      <td>POINT (176.55000 -12.25000)</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2020346S13168</td>
      <td>4</td>
      <td>0.000000</td>
      <td>332.826260</td>
      <td>POINT (176.55000 -12.35000)</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2020346S13168</td>
      <td>5</td>
      <td>0.000000</td>
      <td>321.990248</td>
      <td>POINT (176.55000 -12.45000)</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>33931</th>
      <td>2020346S13168_gen5</td>
      <td>5652</td>
      <td>23.326226</td>
      <td>121.094451</td>
      <td>POINT (182.05000 -21.65000)</td>
    </tr>
    <tr>
      <th>33932</th>
      <td>2020346S13168_gen5</td>
      <td>5653</td>
      <td>23.604742</td>
      <td>121.734716</td>
      <td>POINT (182.05000 -21.75000)</td>
    </tr>
    <tr>
      <th>33933</th>
      <td>2020346S13168_gen5</td>
      <td>5654</td>
      <td>23.801646</td>
      <td>122.655530</td>
      <td>POINT (182.05000 -21.85000)</td>
    </tr>
    <tr>
      <th>33934</th>
      <td>2020346S13168_gen5</td>
      <td>5655</td>
      <td>23.909481</td>
      <td>124.089118</td>
      <td>POINT (182.05000 -21.95000)</td>
    </tr>
    <tr>
      <th>33935</th>
      <td>2020346S13168_gen5</td>
      <td>5656</td>
      <td>23.923638</td>
      <td>126.015305</td>
      <td>POINT (182.05000 -22.05000)</td>
    </tr>
  </tbody>
</table>
<p>33936 rows × 5 columns</p>
</div>
