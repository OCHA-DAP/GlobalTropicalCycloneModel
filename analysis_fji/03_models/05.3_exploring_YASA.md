```python
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
import matplotlib.patches as mpatches
import numpy as np
import os
from pathlib import Path
import pandas as pd
# import shap
from sklearn.metrics import mean_squared_error
from xgboost.sklearn import XGBRegressor
import geopandas as gpd
from climada.hazard import Centroids, TCTracks, TropCyclone
from shapely.geometry import LineString
from xgboost import plot_importance
import shap

from utils import get_combined_dataset, xgb_model_combined_data_LOOCV, get_training_dataset_complete, get_municipality_grids
```


```python
# Load dataset
df_combined = get_combined_dataset()
df_fji = df_combined[df_combined.country == 'fji']

# # Typhoons
# fji_typhoons = df_fji.typhoon_name.unique()

# Features
features = [
    "wind_speed",
    "track_distance",
    "total_houses",
    "rainfall_max_6h",
    "rainfall_max_24h",
    "coast_length",
    "with_coast",
    "mean_elev",
    "mean_slope",
]
```


```python
input_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_model_features/02_housing_damage/input/"
)
# Actual damage
actual_mun_dmg = pd.read_csv(input_dir / "fji_building_damage_mun_complete.csv")
actual_mun_dmg['typhoon'] = actual_mun_dmg['typhoon'].str.upper()

# Load Fiji Shapefile
fiji = gpd.read_file(
    input_dir / "adm2_shp_fixed.gpkg"
)
fiji = fiji.to_crs('EPSG:4326')

# Load grid
grid_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_model_features/02_housing_damage/output/"
)
grid = gpd.read_file(grid_dir / "fji_0.1_degree_grid_land_overlap_new.gpkg")


# Load typhoon track
tracks_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_model_features/01_windfield"
)
typhoons_info = pd.read_csv(tracks_dir / "typhoons.csv")
typhoons_info.typhoon_name = typhoons_info.typhoon_name.str.upper()
cyclones = actual_mun_dmg['typhoon'].unique()
intersection = typhoons_info[typhoons_info['typhoon_name'].isin(cyclones)].drop_duplicates(keep='last', subset = ['typhoon_name'])
```


```python
# Load Fiji complete
df_fji_complete = get_training_dataset_complete()
df_fji_complete = df_fji_complete[df_fji_complete.typhoon_name != 'ANA'] # Drop ANA
df_fji_complete = df_fji_complete.rename({
    "mean_altitude": "mean_elev",
    "total_buildings": "total_houses",
    "perc_dmg_grid": "percent_houses_damaged"
}, axis=1)
df_fji_complete = df_fji_complete[features + ['typhoon_name', 'grid_point_id', 'Centroid', 'percent_houses_damaged']]
```

## YASA features maps


```python
# Load track
typhoon = 'YASA'
id = intersection[intersection['typhoon_name'] == typhoon].typhoon_id.to_list()
track = TCTracks.from_ibtracs_netcdf(storm_id=id)
tc_track = track.get_track()

points_ib = gpd.points_from_xy(tc_track.lon, tc_track.lat)
tc_track_line_ib = LineString(points_ib)

geometries_ib = gpd.GeoSeries([tc_track_line_ib])
line_gdf_ib = gpd.GeoDataFrame(geometry=geometries_ib)
```


```python
yasa = df_fji_complete[df_fji_complete.typhoon_name == 'YASA']
yasa_gpd = gpd.GeoDataFrame(yasa.merge(grid, left_on='grid_point_id', right_on='id'), geometry='geometry')
```


```python
cmap = 'Reds'

fig, ax = plt.subplots(2,2, figsize=(8,8))
ax = ax.flatten()

yasa_gpd.plot(column='wind_speed', cmap=cmap, linewidth=0.2, ax=ax[0], edgecolor='0.3', legend=True)
line_gdf_ib.plot(ax=ax[0], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black

yasa_gpd.plot(column='rainfall_max_6h', cmap=cmap, linewidth=0.2, ax=ax[1], edgecolor='0.3', legend=True)
line_gdf_ib.plot(ax=ax[1], color='k', linewidth=1, label='Typhoon track')

yasa_gpd.plot(column='track_distance', cmap=cmap, linewidth=0.2, ax=ax[2], edgecolor='0.3', legend=True)
line_gdf_ib.plot(ax=ax[2], color='k', linewidth=1, label='Typhoon track')

yasa_gpd.plot(column='rainfall_max_24h', cmap=cmap, linewidth=0.2, ax=ax[3], edgecolor='0.3', legend=True)
line_gdf_ib.plot(ax=ax[3], color='k', linewidth=1, label='Typhoon track')

ax[0].set_title('Windspeed [m/s]', size=10)
ax[1].set_title('Max Rainfall accumulated \nin 6h [mm]', size=10)
ax[2].set_title('Track distance [Km]', size=10)
ax[3].set_title('Max Rainfall accumulated \nin 24h [mm]', size=10)
ax[0].axis('off')
ax[1].axis('off')
ax[2].axis('off')
ax[3].axis('off')

# All Fiji map
ax[0].set_xlim(176, 182)
ax[0].set_ylim(-20, -12)
ax[1].set_xlim(176, 182)
ax[1].set_ylim(-20, -12)
ax[2].set_xlim(176, 182)
ax[2].set_ylim(-20, -12)
ax[3].set_xlim(176, 182)
ax[3].set_ylim(-20, -12)

plt.suptitle('YASA')
plt.tight_layout()
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_7_0.png)




```python
cmap = 'Reds'

fig, ax = plt.subplots(2,2, figsize=(8,8))
ax = ax.flatten()

yasa_gpd.plot(column='mean_slope', cmap=cmap, linewidth=0.2, ax=ax[0], edgecolor='0.3', legend=True)
line_gdf_ib.plot(ax=ax[0], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black

yasa_gpd.plot(column='mean_elev', cmap=cmap, linewidth=0.2, ax=ax[1], edgecolor='0.3', legend=True)
line_gdf_ib.plot(ax=ax[1], color='k', linewidth=1, label='Typhoon track')

yasa_gpd.plot(column='coast_length', cmap=cmap, linewidth=0.2, ax=ax[2], edgecolor='0.3', legend=True)
line_gdf_ib.plot(ax=ax[2], color='k', linewidth=1, label='Typhoon track')

yasa_gpd.plot(column='total_houses', cmap=cmap, linewidth=0.2, ax=ax[3], edgecolor='0.3', legend=True)
line_gdf_ib.plot(ax=ax[3], color='k', linewidth=1, label='Typhoon track')

ax[0].set_title('Mean Slope [degree]', size=10)
ax[1].set_title('Mean Elevation [m]', size=10)
ax[2].set_title('Coast Length [m]', size=10)
ax[3].set_title('Total houses', size=10)
ax[0].axis('off')
ax[1].axis('off')
ax[2].axis('off')
ax[3].axis('off')

# All Fiji map
ax[0].set_xlim(176, 182)
ax[0].set_ylim(-20, -12)
ax[1].set_xlim(176, 182)
ax[1].set_ylim(-20, -12)
ax[2].set_xlim(176, 182)
ax[2].set_ylim(-20, -12)
ax[3].set_xlim(176, 182)
ax[3].set_ylim(-20, -12)

plt.suptitle('YASA')
plt.tight_layout()
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_8_0.png)



## The Model


```python
# Stratification
dmg = np.array(df_fji.percent_houses_damaged.to_list())
zero_dmg = np.round((np.count_nonzero(dmg == 0) / len(dmg)) , 2 )

# Define ranges for each group
x0 = list(np.linspace(0, zero_dmg, 1))   # zero damage
x1 = list(np.linspace(zero_dmg, 0.93, 2))  # almost no damage
x2 = list(np.linspace(0.935, 1, 5))  # all the damage
x3=x0+x1+x2

bins = []
for i in x3:
    bins.append(np.quantile(dmg, i))

# Histogram after stratification
samples_per_bin_fji, bins_def_fji = np.histogram(dmg, bins=bins)

# Define number of bins
num_bins_fji = len(samples_per_bin_fji)

# For future plots
str_bin_fji = []
for i in range(len(bins_def_fji[:-1])):
    a = str(np.round(bins_def_fji[i+1],3))
    b = str(np.round(bins_def_fji[i],3))
    str_bin_fji.append('{} - {}'.format(b,a))
```


```python
# Run XGB

# # Load Fiji complete
# df_fji_complete = get_training_dataset_complete()
# df_fji_complete = df_fji_complete[df_fji_complete.typhoon_name != 'ANA'] # Drop ANA
# df_fji_complete = df_fji_complete.rename({
#     "mean_altitude": "mean_elev",
#     "total_buildings": "total_houses",
#     "perc_dmg_grid": "percent_houses_damaged"
# }, axis=1)
# df_fji_complete = df_fji_complete[features + ['typhoon_name', 'grid_point_id', 'Centroid', 'percent_houses_damaged']]

# Drop ANA typhoon
df_combined_noana = df_combined[df_combined.typhoon_name != 'ANA']
df_fji_noana= df_fji_complete[df_fji_complete.typhoon_name != 'ANA']

# Drop ADMIN 1 typhoons + ANA
admin1 = ['TOMAS', 'TINO', 'SARAI', 'EVAN', 'ANA']
df_combined_no_adm1 = df_combined[~df_combined.typhoon_name.isin(admin1)]
df_fji_no_adm1 = df_fji[~df_fji.typhoon_name.isin(admin1)]


# Features
features = [
    "wind_speed",
    "track_distance",
    "total_houses",
    "rainfall_max_6h",
    "rainfall_max_24h",
    "coast_length",
    "with_coast",
    "mean_elev",
    "mean_slope",
]

y_test_typhoon, y_pred_typhoon, rmse_strat, avg_error_strat = xgb_model_combined_data_LOOCV(
    df_combined=df_combined_noana,
    df_fji=df_fji_noana,
    bins=bins_def_fji,
    fji_weight=6,
    features=features
)
```

### Results at municipality level


```python
# Since we need the grid id, we load this dataset. Is the same one as df_fji (same orde rof rows, same information, etc)
# but we the feature 'grid_point_id' not present in df_fji from get_combined_dataset()
# (here we drop this value because grid ids from Fiji and philippines are different)

# Add feature "predictive_damage"
# df_fji_complete['predicted_damage'] = np.concatenate(y_pred_typhoon)

# Fiji typhoons
fji_typhoons = df_fji_noana.typhoon_name.unique()

# Calculate buildings destroyed by municipality and % of buildings destroyed by mun
mun_id = get_municipality_grids()[['id','NAME_2']]

def num_bld_destroyed_mun(mun, typhoon, real = False):
    k = fji_typhoons.tolist().index(typhoon)
    df_typhoon = df_fji_complete[df_fji_complete.typhoon_name==typhoon]
    # Add feature "predictive_damage"
    df_typhoon['predicted_damage'] = y_pred_typhoon[k]

    mun_ids = mun_id[mun_id.NAME_2 == mun].id.to_list()
    cells_in_mun = df_typhoon[df_typhoon.typhoon_name == typhoon].set_index('grid_point_id').loc[mun_ids]

    if real:
        damage_grid = np.array(cells_in_mun.percent_houses_damaged.to_list()) # Real dmg
    else:
        damage_grid = np.array(cells_in_mun.predicted_damage.to_list()) # Dmg predicted by cell

    # Number of buildings
    N_bld_grid = np.array(cells_in_mun.total_houses.to_list()) # Bld by cell
    N_bld_mun = np.sum(N_bld_grid) # Total bld in mun

    # Calculate % of buildings (and N of bld) destroyed by mun
    N_bld_dest_pred_mun = np.sum(damage_grid) * (N_bld_mun / 100)
    perc_destroyed_mun = np.sum(damage_grid)

    return N_bld_dest_pred_mun, perc_destroyed_mun

# Create new features in shapefile with predicted and real damage
typhoon='YASA'
def calculate_actual_perc_dmg(x, i):
    try:
        return num_bld_destroyed_mun(mun=x['NAME_2'], typhoon=typhoon, real=True)[i]
    except:
        return 0
def calculate_pred_perc_dmg(x, i):
    try:
        return num_bld_destroyed_mun(mun=x['NAME_2'], typhoon=typhoon, real=False)[i]
    except:
        return 0
fiji['actual_perc_dmg'] = fiji.apply(calculate_actual_perc_dmg, i=1, axis=1)
fiji['actual_bld_dest'] = fiji.apply(calculate_actual_perc_dmg, i=0, axis=1)
fiji['pred_perc_dmg'] = fiji.apply(calculate_pred_perc_dmg, i=1, axis=1)
fiji['pred_bld_dmg'] = fiji.apply(calculate_pred_perc_dmg, i=0, axis=1)
fiji['prediction_error'] = fiji['actual_perc_dmg'] - fiji['pred_perc_dmg'] # in percentual points

# Load track
id = intersection[intersection['typhoon_name'] == typhoon].typhoon_id.to_list()
track = TCTracks.from_ibtracs_netcdf(storm_id=id)
tc_track = track.get_track()

points_ib = gpd.points_from_xy(tc_track.lon, tc_track.lat)
tc_track_line_ib = LineString(points_ib)

geometries_ib = gpd.GeoSeries([tc_track_line_ib])
line_gdf_ib = gpd.GeoDataFrame(geometry=geometries_ib)
```


```python
# Plotting the data
cmap='Reds'
cmap_blue = 'Blues'
cmap_red = 'Reds_r'
fig, ax = plt.subplots(1, 3, figsize=(15, 5))
vmax = max([fiji.actual_perc_dmg.max(), fiji.pred_perc_dmg.max()])

# Check prediction_error column for values > 0 and < 0
positive_error = fiji[fiji['prediction_error'] > 0]
negative_error = fiji[fiji['prediction_error'] < 0]

# Plotting the maps
fiji_plot_1 = fiji.plot(column='actual_perc_dmg', cmap=cmap, linewidth=0.2, ax=ax[0], edgecolor='0.3', legend=True)
fiji_plot_2 = fiji.plot(column='pred_perc_dmg', cmap=cmap, linewidth=0.2, ax=ax[1], edgecolor='0.3', legend=True)
#fiji_plot_3 = fiji.plot(column='prediction_error', cmap='RdBu', linewidth=0.2, ax=ax[2], edgecolor='0.3', legend=True)
fiji_plot_3_blue = positive_error.plot(column='prediction_error', cmap=cmap_blue, linewidth=0.2, ax=ax[2], edgecolor='0.3', legend=True)
fiji_plot_3_red = negative_error.plot(column='prediction_error', cmap=cmap_red, linewidth=0.2, ax=ax[2], edgecolor='0.3', legend=True)


line_gdf_ib.plot(ax=ax[0], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black
line_gdf_ib.plot(ax=ax[1], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black
line_gdf_ib.plot(ax=ax[2], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black

# Create custom legends
blue_patch = mpatches.Patch(color='#6495ED', label='Underestimated damage')
red_patch = mpatches.Patch(color='#800000', label='Overestimated damage')
ax[2].legend(handles=[blue_patch, red_patch], loc='lower left', bbox_to_anchor=(-0.05, -0.2))

ax[0].set_title('Actual Damage by municipality')
ax[1].set_title('Predicted Damage by municipality')
ax[2].set_title('Prediction Error \n $actual_{dmg} - predicted_{dmg}$ \n(in percentage points)')
ax[0].axis('off')
ax[1].axis('off')
ax[2].axis('off')

# Localize big islands
# ax[0].set_xlim(176.5, 182)
# ax[0].set_ylim(-20, -15)
# ax[1].set_xlim(176.5, 182)
# ax[1].set_ylim(-20, -15)
# ax[2].set_xlim(176.5, 182)
# ax[2].set_ylim(-20, -15)

# All Fiji map
ax[0].set_xlim(176, 182)
ax[0].set_ylim(-20, -12)
ax[1].set_xlim(176, 182)
ax[1].set_ylim(-20, -12)
ax[2].set_xlim(176, 182)
ax[2].set_ylim(-20, -12)

plt.suptitle('Typhoon {} (drop ANA)'.format(typhoon), y=1.1)
plt.tight_layout()
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_14_0.png)



### Now at grid level


```python
typhoon = 'YASA'

# Merge with grid to add geometry
df_fji_complete_merged = grid[['id','geometry']].merge(df_fji_complete, left_on='id', right_on='grid_point_id')
df_fji_complete_merged = gpd.GeoDataFrame(df_fji_complete_merged, geometry='geometry')

k = fji_typhoons.tolist().index(typhoon)
df_typhoon_grid = df_fji_complete_merged[df_fji_complete_merged.typhoon_name==typhoon]
# Add feature "predictive_damage"
df_typhoon_grid['predicted_damage'] = y_pred_typhoon[k]

# Check prediction_error column for values > 0 and < 0
positive_error_grid = df_typhoon_grid[df_typhoon_grid['predicted_damage'] > 0]
negative_error_grid = df_typhoon_grid[df_typhoon_grid['predicted_damage'] < 0]


fig, ax = plt.subplots(1,2, figsize=(10,5))

df_typhoon_grid.plot(column='percent_houses_damaged', cmap=cmap, linewidth=0.8, ax=ax[0], edgecolor='0.8', legend=True)
df_typhoon_grid.plot(column='predicted_damage', cmap=cmap, linewidth=0.8, ax=ax[1], edgecolor='0.8', legend=True, vmin=0)
# grid_plot_3_red = positive_error_grid.plot(column='predicted_damage', cmap=cmap_red, linewidth=0.2, ax=ax[1], edgecolor='0.3', legend=True)
# grid_plot_3_blue = negative_error_grid.plot(column='predicted_damage', cmap=cmap_blue, linewidth=0.2, ax=ax[1], edgecolor='0.3', legend=True)

line_gdf_ib.plot(ax=ax[0], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black
line_gdf_ib.plot(ax=ax[1], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black


ax[0].set_title('Actual Damage by grid')
ax[1].set_title('Predicted Damage by grid')
ax[0].axis('off')
ax[1].axis('off')
ax[0].set_xlim(176.5, 182)
ax[0].set_ylim(-20, -15)
ax[1].set_xlim(176.5, 182)
ax[1].set_ylim(-20, -15)

plt.suptitle('Typhoon {}'.format(typhoon), y=1)
plt.tight_layout()
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_16_0.png)



### Origin of the problem


```python
# Predicitons for High affected municipalities: which are these municipalities?

fig, ax  = plt.subplots(1,1, figsize=(8,8))
fiji.plot(linewidth=0.4, ax=ax, edgecolor='0.05', color='lightblue')
# Add annotations for NAME_2
for idx, row in fiji.iterrows():
    ax.annotate(text=row['NAME_2'], xy=(row.geometry.centroid.x, row.geometry.centroid.y),
                ha='center', weight='bold', color='k', size=7)

# Localize big islands
ax.set_xlim(176.5, 182)
ax.set_ylim(-20, -15)
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_18_0.png)



So, we wanna know what's happening in **Macuata**, **Cakaudrove** and, for a baseline, **Naitasiri**.


```python
# Cells ids for each municipality
naitasiri_ids = mun_id[mun_id['NAME_2'] == 'Naitasiri'].id.to_list()
ra_ids = mun_id[mun_id['NAME_2'] == 'Ra'].id.to_list()
macuata_ids = mun_id[mun_id['NAME_2'] == 'Macuata'].id.to_list()
cakaudrove_ids = mun_id[mun_id['NAME_2'] == 'Cakaudrove'].id.to_list()

typhoon = 'YASA'
location_ids = naitasiri_ids
```

We run the model again. We are going to explain a specific model that test on YASA.


```python
# Define the model
fji_weight = 6

# Define df_fji with grid_point_id
df_fji_mod = df_fji_complete.rename({'perc_dmg_grid':'percent_houses_damaged'}, axis=1)#.drop('predicted_damage', axis=1)
df_fji_mod = df_fji_mod[df_fji_mod.typhoon_name != 'ANA'] # Drop ANA
fji_typhoons = df_fji_mod.typhoon_name.unique()

# Bins
num_bins = len(bins)

features = [
    "wind_speed",
    "track_distance",
    "total_houses",
    "rainfall_max_6h",
    "rainfall_max_24h",
    "coast_length",
    "with_coast",
    "mean_elev",
    "mean_slope",
]

y_test_typhoon_fji  = []
y_pred_typhoon_fji  = []
#for typhoon in fji_typhoons:
""" PART 1: Train/Test """

# LOOCV
df_test = df_fji_mod[df_fji_mod["typhoon_name"] == typhoon].reset_index(drop=False) # Test set: Fiji
df_train = df_combined_noana[df_combined_noana["typhoon_name"] != typhoon] # Train set: everything

# Class weight
weights = np.where(df_train['country'] == 'phl', 1, fji_weight) # Let's give more weight to Fiji

# Split X and y from dataframe features
X_test = df_test[features]
X_train = df_train[features]

y_train = df_train["percent_houses_damaged"]
y_test = df_test["percent_houses_damaged"]

# Stratify data
bin_index_test = np.digitize(y_test, bins=bins[:-1])

""" PART 2: XGB regressor """
# create an XGBoost Regressor
xgb = XGBRegressor(
    base_score=0.5,
    booster="gbtree",
    colsample_bylevel=0.8,
    colsample_bynode=0.8,
    colsample_bytree=0.8,
    gamma=3,
    eta=0.01,
    importance_type="gain",
    learning_rate=0.1,
    max_delta_step=0,
    max_depth=4,
    min_child_weight=1,
    missing=1,
    n_estimators=100,
    early_stopping_rounds=10,
    n_jobs=1,
    nthread=None,
    objective="reg:squarederror",
    reg_alpha=0,
    reg_lambda=1,
    scale_pos_weight=1,
    seed=None,
    silent=None,
    subsample=0.8,
    verbosity=0,
    eval_metric=["rmse", "logloss"],
    random_state=0,
)

# Fit the model
eval_set = [(X_train, y_train)]
xgb.fit(X_train, y_train, eval_set=eval_set, verbose=False, sample_weight=weights) #xgb_model

# make predictions on Fiji
y_pred_fji = xgb.predict(X_test)

# Save y_test y_pred
y_test_typhoon_fji.append(y_test)
y_pred_typhoon_fji.append(y_pred_fji)
```


```python
# Initialize an explainer for the typhoon
explainer = shap.Explainer(xgb, X_test)
shap_values = explainer(X_test)
```

    [11:54:48] WARNING: /Users/runner/work/xgboost/xgboost/src/c_api/c_api.cc:1240: Saving into deprecated binary model format, please consider using `json` or `ubj`. Model format will default to JSON in XGBoost 2.2 if not specified.



```python
# What are SHAP values?
shap_values[0]
#.values() are the values of importance for each feature
#.base_values() are the mean of the values of the features for all X_test
#.data is just X_test[i] -- do X_test.loc[0] to get shap_values[0]
```




    .values =
    array([-1.09639396e-01,  8.14700289e-02, -7.61094514e-03,  2.09703366e-05,
            0.00000000e+00, -6.57403610e-03,  5.87934162e-04, -1.25554390e-03,
           -1.18634339e-03])

    .base_values =
    0.03914149738408014

    .data =
    array([ 19.10289292, 162.74033409,   0.        ,   1.5       ,
             0.50416667, 224.97654198,   1.        ,   0.        ,
             0.        ])




```python
shap.plots.bar(shap_values,show=False)
plt.title('SHAP values for {} typhoon'.format(typhoon))
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_25_0.png)




```python
# Localize index in X_test (or df_test.. idem)
loc_index_mac = df_test[df_test['grid_point_id'].isin(macuata_ids)].index.to_list()
loc_index_cak = df_test[df_test['grid_point_id'].isin(cakaudrove_ids)].index.to_list()
loc_index_nai = df_test[df_test['grid_point_id'].isin(naitasiri_ids)].index.to_list()
# All values of importance by grid
importance_by_cell_mac = shap_values[loc_index_mac]
importance_by_cell_cak = shap_values[loc_index_cak]
importance_by_cell_nai = shap_values[loc_index_nai]
# Now take the mean for each feature across every cell to get the feature importance for the municipality
importance_municipality_mac = importance_by_cell_mac.mean(0)
importance_municipality_cak = importance_by_cell_cak.mean(0)
importance_municipality_nai = importance_by_cell_nai.mean(0)
# Summary plot of SHAP values for the specific location
shap.plots.bar(importance_municipality_mac,show=False)
plt.title('Mean values of importance \nover all grid cells in Macuata')
plt.show()

shap.plots.bar(importance_municipality_cak,show=False)
plt.title('Mean values of importance \nover all grid cells in Cakaudrove')
plt.show()

shap.plots.bar(importance_municipality_nai,show=False, )
plt.title('Mean values of importance \nover all grid cells in Naitasiri')
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_26_0.png)





![png](05.3_exploring_YASA_files/05.3_exploring_YASA_26_1.png)





![png](05.3_exploring_YASA_files/05.3_exploring_YASA_26_2.png)



It makes sense:

- For Macuata and Cakaudrove, Windspeed positiviely correlates with the results predicted and Track Distance negatively correlates with the predictions. This is fine! The higher the windspeed and the closer to the track, the more damage we receive.

The problem arises because we wanted more damage to be predicted for Macuata.

- For Naitasiri, is the opposite: windspeed is low and track distace in high, so Windspeed negatively correlates with damage predicted (no damage was predicted) and track distance positeveluy correlates with the prediction.

What if we focus on high predicted damage cells rather than all cells in a municipality... I believe it's going to be analogous, but it's worthy to check it out.


```python
# the typhoon
df_typhoon = df_fji_complete[df_fji_complete['typhoon_name'] == typhoon]
df_typhoon['predicted_damage'] = y_pred_fji

# Focus on Cakaudrove IDs
df_cakaudrove = df_typhoon[df_typhoon.grid_point_id.isin(cakaudrove_ids)]
df_cakaudrove = df_cakaudrove.sort_values('predicted_damage', ascending=False)
df_cakaudrove.head(5)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>wind_speed</th>
      <th>track_distance</th>
      <th>total_houses</th>
      <th>rainfall_max_6h</th>
      <th>rainfall_max_24h</th>
      <th>coast_length</th>
      <th>with_coast</th>
      <th>mean_elev</th>
      <th>mean_slope</th>
      <th>typhoon_name</th>
      <th>grid_point_id</th>
      <th>Centroid</th>
      <th>percent_houses_damaged</th>
      <th>predicted_damage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2482</th>
      <td>65.473931</td>
      <td>16.665339</td>
      <td>940</td>
      <td>0.158333</td>
      <td>0.072917</td>
      <td>26130.063456</td>
      <td>1</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>YASA</td>
      <td>2977</td>
      <td>179.45E_-16.75N</td>
      <td>0.262414</td>
      <td>1.140963</td>
    </tr>
    <tr>
      <th>2806</th>
      <td>41.032291</td>
      <td>10.539952</td>
      <td>329</td>
      <td>0.241667</td>
      <td>0.154167</td>
      <td>9763.180622</td>
      <td>1</td>
      <td>38.319444</td>
      <td>14.731385</td>
      <td>YASA</td>
      <td>3383</td>
      <td>179.85E_-16.95N</td>
      <td>0.091845</td>
      <td>1.037660</td>
    </tr>
    <tr>
      <th>2896</th>
      <td>46.190478</td>
      <td>14.053222</td>
      <td>485</td>
      <td>0.700000</td>
      <td>0.425000</td>
      <td>42709.946912</td>
      <td>1</td>
      <td>22.537809</td>
      <td>12.359525</td>
      <td>YASA</td>
      <td>3484</td>
      <td>179.95E_-16.95N</td>
      <td>0.135395</td>
      <td>0.964949</td>
    </tr>
    <tr>
      <th>3094</th>
      <td>46.976876</td>
      <td>45.672790</td>
      <td>692</td>
      <td>0.200000</td>
      <td>0.095833</td>
      <td>86393.572450</td>
      <td>1</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>YASA</td>
      <td>3785</td>
      <td>180.25E_-16.75N</td>
      <td>0.193182</td>
      <td>0.886996</td>
    </tr>
    <tr>
      <th>2266</th>
      <td>50.764279</td>
      <td>12.221190</td>
      <td>1129</td>
      <td>0.958333</td>
      <td>0.281250</td>
      <td>13813.175377</td>
      <td>1</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>YASA</td>
      <td>2774</td>
      <td>179.25E_-16.65N</td>
      <td>0.315176</td>
      <td>0.870370</td>
    </tr>
  </tbody>
</table>
</div>




```python
# Lets consider the top 4 grid cells with more predicted damage.
hd_ids_cak = df_cakaudrove.iloc[:4].grid_point_id.to_list()

# Locate this cells in the X test
loc_index_hd = df_test[df_test['grid_point_id'].isin(hd_ids_cak)].index.to_list()

# The grid cell with the most predicted damage
importance_most_dmg_pred_cell = shap_values[loc_index_hd[0]]

# Mean over 4 cell with more pred dmg
importance_4_most_dmg_pred_cells = shap_values[loc_index_hd].mean(0)

# Summary plot of SHAP values for the specific location
shap.plots.bar(importance_most_dmg_pred_cell, show=False)
plt.title('Grid with the most predicted damage in Cakaudrove')
plt.show()

# Summary plot of SHAP values for the specific location
shap.plots.bar(importance_4_most_dmg_pred_cells,show=False)
plt.title('Mean values of importance \nover 4 grid cells with the most predicted \ndamage in Cakaudrove')
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_30_0.png)





![png](05.3_exploring_YASA_files/05.3_exploring_YASA_30_1.png)



What about other non-damaged municipality: Ra


```python
mun = 'Ra'
mun_ids = ra_ids
# Localize index in X_test (or df_test.. idem)
loc_index_ra = df_test[df_test['grid_point_id'].isin(mun_ids)].index.to_list()

# All values of importance by grid
importance_by_cell_ra = shap_values[loc_index_ra]

# Now take the mean for each feature across every cell to get the feature importance for the municipality
importance_municipality_ra = importance_by_cell_ra.mean(0)

# Summary plot of SHAP values for the specific location
shap.plots.bar(importance_municipality_ra,show=False)
plt.title('Mean values of importance \nover all grid cells in {}'.format(mun))
plt.show()

```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_32_0.png)



## Some relationship between features

It makes no sense:

- track_distance has a negative impact in the prediction of high damage for a municipality that suffered high damage

- track_distance has a positive impact in the prediction of no/low damage in proveinces where no damage was recorded.

Shouldn't be the opposite way?


```python
dmg_yasa = df_typhoon.percent_houses_damaged
wind_yasa = df_typhoon.wind_speed

plt.plot(dmg_yasa, wind_yasa ,' go')
plt.xlabel('Real Damage [%]')
plt.ylabel('Windspeed [m/s]')
plt.title('At country level for YASA')
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_35_0.png)




```python
# Put a threshold on windspeed values
wind_thres = 25
df_typhoon_thres = df_typhoon[df_typhoon.wind_speed >= wind_thres]

dmg_yasa_drop = df_typhoon_thres.percent_houses_damaged
wind_yasa_drop = df_typhoon_thres.wind_speed

plt.plot(dmg_yasa_drop, wind_yasa_drop ,' go')
plt.xlabel('Real Damage [%]')
plt.ylabel('Windspeed [m/s]')
plt.title('At country level for YASA \n cells with >{} m/s windspeed'.format(wind_thres))
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_36_0.png)




```python
df_macuata = df_typhoon[df_typhoon.grid_point_id.isin(macuata_ids)]
df_macuata = df_macuata.sort_values('predicted_damage', ascending=False)


dmg_yasa_cak = df_cakaudrove.percent_houses_damaged
dmg_pred_yasa_cak = df_cakaudrove.predicted_damage
wind_yasa_cak = df_cakaudrove.wind_speed

dmg_yasa_mac = df_macuata.percent_houses_damaged
dmg_pred_yasa_mac = df_macuata.predicted_damage
wind_yasa_mac = df_macuata.wind_speed

fig, ax = plt.subplots(2,2, figsize=(10,10))
ax = ax.flatten()

ax[0].plot(dmg_yasa_cak, wind_yasa_cak ,' go')
ax[0].set_xlabel('Real Damage [%]')
ax[0].set_ylabel('Windspeed [m/s]')
ax[0].set_title('At Cakaudrove for YASA')

ax[1].plot(dmg_yasa_mac, wind_yasa_mac ,' go')
ax[1].set_xlabel('Real Damage [%]')
ax[1].set_ylabel('Windspeed [m/s]')
ax[1].set_title('At Macuata for YASA')

ax[2].plot(dmg_pred_yasa_cak, wind_yasa_cak ,' go')
ax[2].set_xlabel('Predicted Damage [%]')
ax[2].set_ylabel('Windspeed [m/s]')
ax[2].set_title('At Cakaudrove for YASA')

ax[3].plot(dmg_pred_yasa_mac, wind_yasa_mac ,' go')
ax[3].set_xlabel('Predicted Damage [%]')
ax[3].set_ylabel('Windspeed [m/s]')
ax[3].set_title('At Macuata for YASA')


plt.tight_layout()
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_37_0.png)




```python
df_macuata = df_typhoon[df_typhoon.grid_point_id.isin(macuata_ids)]
df_macuata = df_macuata.sort_values('predicted_damage', ascending=False)

track_yasa_cak = df_cakaudrove.track_distance
wind_yasa_cak = df_cakaudrove.wind_speed

track_yasa_mac = df_macuata.track_distance
wind_yasa_mac = df_macuata.wind_speed

fig, ax = plt.subplots(1,3, figsize=(10,5))

ax[0].plot(track_yasa_cak, wind_yasa_cak ,' go')
ax[0].set_xlabel('Track Distance [Km]')
ax[0].set_ylabel('Windspeed [m/s]')
ax[0].set_title('At Cakaudrove for YASA')
ax[0].set_ylim([0,70])

ax[1].plot(track_yasa_mac, wind_yasa_mac ,' go')
ax[1].set_xlabel('Track Distance [Km]')
ax[1].set_ylabel('Windspeed [m/s]')
ax[1].set_title('At Macuata for YASA')
ax[1].set_ylim([0,70])

ax[2].plot(df_typhoon.track_distance, df_typhoon.wind_speed ,' go')
ax[2].set_xlabel('Track Distance [Km]')
ax[2].set_ylabel('Windspeed [m/s]')
ax[2].set_title('YASA, country level')

plt.tight_layout()
plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_38_0.png)



### Define threshold


```python
fig, ax = plt.subplots(1,1)
df_typhoon.plot(kind='scatter', x='track_distance', y='wind_speed', c='percent_houses_damaged',
                alpha=0.8, cmap='Reds',ax=ax)
ax.set_xlabel('Track Distance [Km]')
ax.set_ylabel('Windspeed [m/s]')
ax.set_title('YASA, grid level')

plt.show()
```



![png](05.3_exploring_YASA_files/05.3_exploring_YASA_40_0.png)
