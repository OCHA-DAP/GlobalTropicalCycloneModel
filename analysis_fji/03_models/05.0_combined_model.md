Here we apply all that we have been studying in this folder.


```python
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
import matplotlib.patches as mpatches
import numpy as np
import os
from pathlib import Path
import pandas as pd
import geopandas as gpd
from climada.hazard import Centroids, TCTracks, TropCyclone
from shapely.geometry import LineString

from utils import get_combined_dataset, xgb_model_combined_data_LOOCV, get_training_dataset_complete, get_municipality_grids
```


```python
# For Checking (Number of buildings destroyed per mun)
input_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_model_features/02_housing_damage/input/"
)
actual_mun_dmg = pd.read_csv(input_dir / "fji_building_damage_mun_complete.csv")
actual_mun_dmg['typhoon'] = actual_mun_dmg['typhoon'].str.upper()

# Load Fiji Shapefile
fiji = gpd.read_file(
    input_dir / "adm2_shp_fixed.gpkg"
)
fiji = fiji.to_crs('EPSG:4326')

# Load grid
grid_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_model_features/02_housing_damage/output/"
)
grid = gpd.read_file(grid_dir / "fji_0.1_degree_grid_land_overlap_new.gpkg")


# Load typhoon track
tracks_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_model_features/01_windfield"
)
typhoons_info = pd.read_csv(tracks_dir / "typhoons.csv")
typhoons_info.typhoon_name = typhoons_info.typhoon_name.str.upper()
cyclones = actual_mun_dmg['typhoon'].unique()
intersection = typhoons_info[typhoons_info['typhoon_name'].isin(cyclones)].drop_duplicates(keep='last', subset = ['typhoon_name'])

```


```python
# Load dataset
df_combined = get_combined_dataset()
df_fji = df_combined[df_combined.country == 'fji']

# Typhoons
fji_typhoons = df_fji.typhoon_name.unique()

# Features
features = [
    "wind_speed",
    "track_distance",
    "total_houses",
    "rainfall_max_6h",
    "rainfall_max_24h",
    "coast_length",
    "with_coast",
    "mean_elev",
    "mean_slope",
]
```


```python
# Stratification
dmg = np.array(df_fji.percent_houses_damaged.to_list())
zero_dmg = np.round((np.count_nonzero(dmg == 0) / len(dmg)) , 2 )

# Define ranges for each group
x0 = list(np.linspace(0, zero_dmg, 1))   # zero damage
x1 = list(np.linspace(zero_dmg, 0.93, 2))  # almost no damage
x2 = list(np.linspace(0.935, 1, 5))  # all the damage
x3=x0+x1+x2

bins = []
for i in x3:
    bins.append(np.quantile(dmg, i))

# Histogram after stratification
samples_per_bin_fji, bins_def_fji = np.histogram(dmg, bins=bins)

# Define number of bins
num_bins_fji = len(samples_per_bin_fji)

# For future plots
str_bin_fji = []
for i in range(len(bins_def_fji[:-1])):
    a = str(np.round(bins_def_fji[i+1],3))
    b = str(np.round(bins_def_fji[i],3))
    str_bin_fji.append('{} - {}'.format(b,a))
```


```python
# Drop ANA typhoon
df_combined_noana = df_combined[df_combined.typhoon_name != 'ANA']
df_fji_noana= df_fji[df_fji.typhoon_name != 'ANA']
fji_typhoons = df_fji_noana.typhoon_name.unique()
```

Here:

-  set weight sample ratio for XGB Regressor model to >= 3:1 ratio
-  Drop ANA typhoon from the discussion (Dmg values are wrong labeled)


```python
# Run XGB
y_test_typhoon, y_pred_typhoon, rmse_strat, avg_error_strat = xgb_model_combined_data_LOOCV(
    df_combined=df_combined_noana,
    df_fji=df_fji_noana,
    bins=bins_def_fji,
    fji_weight=6,
    features=features
)
```

### Results at municipality level

Comparing results at municipality level


```python
# Since we need the grid id, we load this dataset. Is the same one as df_fji (same orde rof rows, same information, etc)
# but we the feature 'grid_point_id' not present in df_fji from get_combined_dataset()
# (here we drop this value because grid ids from Fiji and philippines are different)

df_fji_complete = get_training_dataset_complete()
df_fji_complete = df_fji_complete[df_fji_complete.typhoon_name != 'ANA'] # Drop ANA
df_fji_complete = df_fji_complete.rename({
    "mean_altitude": "mean_elev",
    "total_buildings": "total_houses"
}, axis=1)
df_fji_complete = df_fji_complete[features + ['typhoon_name', 'grid_point_id', 'Centroid', 'perc_dmg_grid']]
```


```python
# Calculate buildings destroyed by municipality and % of buildings destroyed by mun
mun_id = get_municipality_grids()[['id','NAME_2']]
def num_bld_destroyed_mun(mun, typhoon, real = False):

    k = fji_typhoons.tolist().index(typhoon)
    df_typhoon = df_fji_complete[df_fji_complete.typhoon_name==typhoon]
    # Add feature "predictive_damage"
    df_typhoon['predicted_damage'] = y_pred_typhoon[k]

    mun_ids = mun_id[mun_id.NAME_2 == mun].id.to_list()
    cells_in_mun = df_typhoon[df_typhoon.typhoon_name == typhoon].set_index('grid_point_id').loc[mun_ids]

    if real:
        damage_grid = np.array(cells_in_mun.perc_dmg_grid.to_list()) # Real dmg
    else:
        damage_grid = np.array(cells_in_mun.predicted_damage.to_list()) # Dmg predicted by cell

    # Number of buildings
    N_bld_grid = np.array(cells_in_mun.total_houses.to_list()) # Bld by cell
    N_bld_mun = np.sum(N_bld_grid) # Total bld in mun

    #N_bld_dest_pred_mun = (damage_grid / (N_bld_grid)) * (N_bld_mun ** 2) / 100
    # Calculate % of buildings destroyed by mun in an understandable way
    #perc_destroyed_mun = 100 * np.sum(N_bld_grid * N_bld_dest_pred_mun) / (N_bld_mun ** 2) # Basically np.sum(damage_grid)
    #perc_destroyed_mun = 100 * N_bld_dest_pred_mun / N_bld_mun

    # Calculate % of buildings (and N of bld) destroyed by mun
    N_bld_dest_pred_mun = np.sum(damage_grid) * (N_bld_mun / 100)
    perc_destroyed_mun = np.sum(damage_grid)

    return N_bld_dest_pred_mun, perc_destroyed_mun
```


```python
# Some checks (to see if we're counting ok)
mun='Naitasiri'
typhoon='WINSTON'
print('Calculated:', num_bld_destroyed_mun(mun=mun, typhoon=typhoon, real=True))
print('Actual: ', actual_mun_dmg[(actual_mun_dmg['typhoon']==typhoon) & (actual_mun_dmg['ADM2_NAME'] == mun)].total.to_list()[0])
```

    Calculated: (906.9999999999994, 1.8983632634266807)
    Actual:  907.0



```python
# Actual vs prediction
mun='Naitasiri'
typhoon='WINSTON'
print('Predicted:', num_bld_destroyed_mun(mun=mun, typhoon=typhoon, real=False))
```

    Predicted: (51288.10461982593, 107.3466964289546)



```python
# Some checks
print(fiji.NAME_2.unique())
print(mun_id.NAME_2.unique())
```

    ['Naitasiri' 'Namosi' 'Rewa' 'Serua' 'Tailevu' 'Kadavu' 'Lau' 'Lomaiviti'
     'Bua' 'Cakaudrove' 'Macuata' 'Rotuma' 'Ba' 'Nadroga/Navosa' 'Ra']
    ['Naitasiri' 'Namosi' 'Rewa' 'Serua' 'Tailevu' 'Kadavu' 'Lau' 'Lomaiviti'
     'Bua' 'Cakaudrove' 'Macuata' 'Rotuma' 'Ba' 'Nadroga/Navosa' 'Ra']



```python
fji_typhoons
```




    array(['TOMAS', 'EVAN', 'WINSTON', 'GITA', 'SARAI', 'TINO', 'HAROLD',
           'YASA'], dtype=object)




```python
# Create new features in shapefile with predicted and real damage
typhoon='EVAN'
def calculate_actual_perc_dmg(x, i):
    try:
        return num_bld_destroyed_mun(mun=x['NAME_2'], typhoon=typhoon, real=True)[i]
    except:
        return 0
def calculate_pred_perc_dmg(x, i):
    try:
        return num_bld_destroyed_mun(mun=x['NAME_2'], typhoon=typhoon, real=False)[i]
    except:
        return 0
fiji['actual_perc_dmg'] = fiji.apply(calculate_actual_perc_dmg, i=1, axis=1)
fiji['actual_bld_dest'] = fiji.apply(calculate_actual_perc_dmg, i=0, axis=1)
fiji['pred_perc_dmg'] = fiji.apply(calculate_pred_perc_dmg, i=1, axis=1)
fiji['pred_bld_dmg'] = fiji.apply(calculate_pred_perc_dmg, i=0, axis=1)
fiji['prediction_error'] = fiji['actual_perc_dmg'] - fiji['pred_perc_dmg'] # in percentual points

# Load track
id = intersection[intersection['typhoon_name'] == typhoon].typhoon_id.to_list()
track = TCTracks.from_ibtracs_netcdf(storm_id=id)
tc_track = track.get_track()

if typhoon == 'TOMAS':
    tc_track['lon'] += 360
    points_ib = gpd.points_from_xy(tc_track.lon, tc_track.lat)
    tc_track_line_ib = LineString(points_ib)
else:
    points_ib = gpd.points_from_xy(tc_track.lon, tc_track.lat)
    tc_track_line_ib = LineString(points_ib)


geometries_ib = gpd.GeoSeries([tc_track_line_ib])
line_gdf_ib = gpd.GeoDataFrame(geometry=geometries_ib)
```

    2023-12-14 14:31:20,764 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.



```python
# Plotting the data
cmap='Reds'
cmap_blue = 'Blues'
cmap_red = 'Reds_r'
fig, ax = plt.subplots(1, 3, figsize=(15, 5))
vmax = max([fiji.actual_perc_dmg.max(), fiji.pred_perc_dmg.max()])

# Check prediction_error column for values > 0 and < 0
positive_error = fiji[fiji['prediction_error'] > 0]
negative_error = fiji[fiji['prediction_error'] < 0]

# Plotting the maps
fiji_plot_1 = fiji.plot(column='actual_perc_dmg', cmap=cmap, linewidth=0.2, ax=ax[0], edgecolor='0.3', legend=True)
fiji_plot_2 = fiji.plot(column='pred_perc_dmg', cmap=cmap, linewidth=0.2, ax=ax[1], edgecolor='0.3', legend=True)
fiji_plot_3_blue = positive_error.plot(column='prediction_error', cmap=cmap_blue, linewidth=0.2, ax=ax[2], edgecolor='0.3', legend=True, vmin=0)
fiji_plot_3_red = negative_error.plot(column='prediction_error', cmap=cmap_red, linewidth=0.2, ax=ax[2], edgecolor='0.3', legend=True, vmax=0)


line_gdf_ib.plot(ax=ax[0], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black
line_gdf_ib.plot(ax=ax[1], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black
line_gdf_ib.plot(ax=ax[2], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black


# Create custom legends
blue_patch = mpatches.Patch(color='#6495ED', label='Underestimated damage')
red_patch = mpatches.Patch(color='#800000', label='Overestimated damage')
ax[2].legend(handles=[blue_patch, red_patch], loc='lower left', bbox_to_anchor=(-0.05, -0.2))

ax[0].set_title('Actual Damage by municipality')
ax[1].set_title('Predicted Damage by municipality')
ax[2].set_title('Prediction Error \n $actual_{dmg} - predicted_{dmg}$ \n(in percentage points)')
ax[0].axis('off')
ax[1].axis('off')
ax[2].axis('off')

# # Localize big islands
# ax[0].set_xlim(176.5, 182)
# ax[0].set_ylim(-20, -15)
# ax[1].set_xlim(176.5, 182)
# ax[1].set_ylim(-20, -15)
# ax[2].set_xlim(176.5, 182)
# ax[2].set_ylim(-20, -15)

# # All Fiji map
# ax[0].set_xlim(176, 182)
# ax[0].set_ylim(-20, -12)
# ax[1].set_xlim(176, 182)
# ax[1].set_ylim(-20, -12)
# ax[2].set_xlim(176, 182)
# ax[2].set_ylim(-20, -12)

# # SARAI
# ax[0].set_xlim(175, 182)
# ax[0].set_ylim(-20, -12)
# ax[1].set_xlim(175, 182)
# ax[1].set_ylim(-20, -12)
# ax[2].set_xlim(175, 182)
# ax[2].set_ylim(-20, -12)

# GITA
ax[0].set_xlim(176, 182)
ax[0].set_ylim(-22, -15)
ax[1].set_xlim(176, 182)
ax[1].set_ylim(-22, -15)
ax[2].set_xlim(176, 182)
ax[2].set_ylim(-22, -15)

plt.suptitle('Typhoon {}'.format(typhoon), y=1.1)
plt.tight_layout()
plt.show()
```



![png](05.0_combined_model_files/05.0_combined_model_17_0.png)



### Results at grid level


```python
# Since we need the grid id, we load this dataset. Is the same one as df_fji (same orde rof rows, same information, etc)
# but we the feature 'grid_point_id' not present in df_fji from get_combined_dataset()
# (here we drop this value because grid ids from Fiji and philippines are different)

df_fji_complete = get_training_dataset_complete()
df_fji_complete = df_fji_complete.rename({
    "mean_altitude": "mean_elev",
    "total_buildings": "total_houses"
}, axis=1)
df_fji_complete = df_fji_complete[features + ['typhoon_name', 'grid_point_id', 'Centroid', 'perc_dmg_grid']]
```


```python
typhoon = 'WINSTON'

# Merge with grid to add geometry
df_fji_complete_merged = grid[['id','geometry']].merge(df_fji_complete, left_on='id', right_on='grid_point_id')
df_fji_complete_merged = gpd.GeoDataFrame(df_fji_complete_merged, geometry='geometry')

# Load track
id = intersection[intersection['typhoon_name'] == typhoon].typhoon_id.to_list()
track = TCTracks.from_ibtracs_netcdf(storm_id=id)
tc_track = track.get_track()

points_ib = gpd.points_from_xy(tc_track.lon, tc_track.lat)
tc_track_line_ib = LineString(points_ib)

geometries_ib = gpd.GeoSeries([tc_track_line_ib])
line_gdf_ib = gpd.GeoDataFrame(geometry=geometries_ib)
```

    2023-12-11 20:28:40,542 - climada.hazard.tc_tracks - WARNING - The cached IBTrACS data set dates from 2023-06-07 23:07:38 (older than 180 days). Very likely, a more recent version is available. Consider manually removing the file /Users/federico/climada/data/IBTrACS.ALL.v04r00.nc and re-running this function, which will download the most recent version of the IBTrACS data set from the official URL.



```python
k = fji_typhoons.tolist().index(typhoon)
df_typhoon_grid = df_fji_complete_merged[df_fji_complete_merged.typhoon_name==typhoon]
# Add feature "predictive_damage"
df_typhoon_grid['predicted_damage'] = y_pred_typhoon[k]

fig, ax = plt.subplots(1,2, figsize=(10,5))

df_typhoon_grid.plot(column='perc_dmg_grid', cmap=cmap, linewidth=0.8, ax=ax[0], edgecolor='0.8', legend=True)
df_typhoon_grid.plot(column='predicted_damage', cmap=cmap, linewidth=0.8, ax=ax[1], edgecolor='0.8', legend=True, vmin=0)

line_gdf_ib.plot(ax=ax[0], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black
line_gdf_ib.plot(ax=ax[1], color='k', linewidth=1, label='Typhoon track')  # Plot the LineString in black


ax[0].set_title('Actual Damage by grid')
ax[1].set_title('Predicted Damage by grid')
ax[0].axis('off')
ax[1].axis('off')
ax[0].set_xlim(176.5, 182)
ax[0].set_ylim(-20, -15)
ax[1].set_xlim(176.5, 182)
ax[1].set_ylim(-20, -15)

plt.suptitle('Typhoon {}'.format(typhoon), y=1)
plt.tight_layout()
plt.show()
```



![png](05.0_combined_model_files/05.0_combined_model_21_0.png)
