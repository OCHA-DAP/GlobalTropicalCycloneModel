```python
from pathlib import Path
import os

from shapely.geometry import LineString,Polygon, MultiPolygon
import geopandas as gpd
import numpy as np
import pandas as pd
import xarray as xr
import re
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from matplotlib.lines import Line2D
from scipy import stats
```


```python
input_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_new_model_input/02_housing_damage/input/"
)
output_dir = (
    Path(os.getenv("STORM_DATA_DIR"))
    / "analysis_fji/02_new_model_input/02_housing_damage/output/"
)

# Load Fiji
fiji = gpd.read_file(input_dir / "adm2_shp_fixed.gpkg")
fiji = fiji.to_crs('EPSG:4326')

# Load grid
grid_land_overlap = gpd.read_file(output_dir / "fji_0.1_degree_grid_land_overlap_new.gpkg")
grid_land_overlap["id"] = grid_land_overlap["id"].astype(int)

# Load grids per Municipality
ids_mun = pd.read_csv(input_dir / "grid_municipality_info.csv")

# Load damage data
damage_data = pd.read_csv(input_dir / "fji_building_damage_mun_complete.csv")

```

## Building locations


```python
gpd_bld_east = gpd.read_file(
    input_dir / "hotosm_fji_east_buildings_polygons_shp.zip"
)
gpd_bld_west = gpd.read_file(
    input_dir / "hotosm_fji_west_buildings_polygons_shp.zip"
)
```

I would like to go from 0 to 360 in the longitude axis. Cannot find a useful crs that satisfy what I want. So let's define one.


```python
# Change crs
custom_crs = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +lon_wrap=360"
east = gpd_bld_east.copy()
east = east.to_crs(custom_crs)

# Define crs for west side
west = gpd_bld_west.copy()
west = west.to_crs('EPSG:4326')
```

I would really want to work with one concatenated dataset but since the CRS of the east and the west are different, we have to work separately.

## Types of buildings


```python
# Type of buildings

bld = pd.concat([east.building, west.building])
fig, ax = plt.subplots(1,1)
ax.hist(bld, bins=50)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, size=8)

plt.show()
```

We just have information about if there are buildings in a location and in some cases, if that builing is a house

### Map of building location


```python
# Plot builing loc over map
fig, ax = plt.subplots(1,1)

fiji.plot(ax=ax, color='gray', edgecolor='gray', label='Fiji')
east.plot(ax=ax, color='red', markersize=10, label='Buildings')
west.plot(ax=ax, color='red', markersize=10, label='Buildings')
ax.set_xlim(175.5, 182.5)
ax.set_ylim(-22,-12)
ax.set_xlabel('Longitude')
ax.set_ylabel('Latitude')
ax.set_title('Fiji builings locations')
# Manually create the legend
legend_elements = [
    Line2D([0], [0], marker='o', color='w', markerfacecolor='red', markersize=10, label='Buildings'),
    Patch(color='gray', label='Fiji')
]

ax.legend(handles=legend_elements, loc='upper left')

plt.savefig('building_location')
plt.show()
```
### Buildings to grid cells


```python
# Centroids
east_centroids = east.copy()
east_centroids["geometry"] = east_centroids["geometry"].centroid

west_centroids = west.copy()
west_centroids["geometry"] = west_centroids["geometry"].centroid
```

```python
# East and West buildings count per grid
east_bld_centroid_grid_count = grid_land_overlap.merge(
    grid_land_overlap.sjoin(east_centroids, how="left")
    .groupby("id")
    .count()
    .building.rename("numbuildings")
    .reset_index()
)

west_bld_centroid_grid_count = grid_land_overlap.merge(
    grid_land_overlap.sjoin(west_centroids, how="left")
    .groupby("id")
    .count()
    .building.rename("numbuildings")
    .reset_index()
)

```

```python
# Combine the two DataFrames
combined_df = pd.concat([east_bld_centroid_grid_count, west_bld_centroid_grid_count], ignore_index=True)

# Keep the maximum value of numbuildings
fji_bld_centroid_grid_count = combined_df.groupby(['id', 'Longitude', 'Latitude', 'Centroid', 'geometry'], as_index=False)['numbuildings'].max()
fji_bld_centroid_grid_count
```
```python
fji_bld_centroid_grid_count.to_csv('numbuildings_per_grid.csv')
```

### Distribution of total houses per grid cell


```python
build_per_grid = fji_bld_centroid_grid_count.numbuildings
plt.hist(build_per_grid, bins=50)
plt.xlabel('Buildings per grid cell')
plt.ylabel('Frequency')


q25 = np.quantile(build_per_grid, 0.25)
q50 = np.quantile(build_per_grid, 0.50)
mode = stats.mode(build_per_grid).mode

# Add text boxes with annotations
plt.text(0.7, 0.9, f'Quantile 25: {q25:.2f}', transform=plt.gca().transAxes)
plt.text(0.7, 0.85, f'Quantile 50: {q50:.2f}', transform=plt.gca().transAxes)
plt.text(0.7, 0.8, f'Mode: {mode:.2f}', transform=plt.gca().transAxes)

plt.show()
```
```python
# Save it
buildings_by_grid = fji_bld_centroid_grid_count[['id','numbuildings']]
buildings_by_grid.to_csv(output_dir / "num_building_bygrid.csv")
```

### Building damage to grid


```python
# Municipalities by id
mun_dict = ids_mun[['id', 'NAME_2']].groupby(by='NAME_2').groups
muns =  mun_dict.keys()
ids = []
for m in muns:
    ids.append(ids_mun.iloc[mun_dict[m].values].id)
df_muns = pd.DataFrame({'Municipality': muns, 'ids':ids})
provinces_exploded = df_muns.explode('ids')
```


```python
# Some checks
print(len(set(ids_mun.sort_values('id').id.unique()) & set(fji_bld_centroid_grid_count.id.unique())))
print(len(set(provinces_exploded.sort_values('ids').ids.unique()) & set(fji_bld_centroid_grid_count.id.unique())))
```

```python
# Assign municipality to fji_bld_centroid_grid_count
bld_grid_mun = fji_bld_centroid_grid_count.merge(provinces_exploded, left_on='id', right_on='ids', how='inner')[['id', 'Municipality', 'numbuildings']]

bld_grid_mun.sort_values('numbuildings', ascending=False)
```
```python
# Because I can: builings by Municipality

df_aux = bld_grid_mun.groupby('Municipality').sum().sort_values(by='numbuildings', ascending=False)

plt.figure(figsize=(12, 6))
plt.bar(df_aux.index, df_aux['numbuildings'])
plt.xlabel('Municipality')
plt.ylabel('Number of Buildings')
plt.title('Number of Buildings by Municipality')
plt.xticks(rotation=45)

plt.show()
```
```python
# Create density of buildings per cell
total_bld_mun = bld_grid_mun.groupby('Municipality').sum()['numbuildings'].reset_index(drop=False)
bld_grid_mun_merged = bld_grid_mun.merge(total_bld_mun, on='Municipality', how='left')
bld_grid_mun_merged['frac_bld'] = bld_grid_mun_merged['numbuildings_x'] / bld_grid_mun_merged['numbuildings_y']
```


```python
# Create percentage of damage per grid cell
bld_damage_merged = damage_data.merge(bld_grid_mun_merged, left_on='ADM2_NAME', right_on = 'Municipality')
bld_damage_merged['perc_dmg_grid'] = bld_damage_merged['frac_bld'] * bld_damage_merged['total'] * 100 / bld_damage_merged['numbuildings_y']

```

### Save % of damage per grid cell


```python
bld_damage_merged
```
```python
bld_damage_merged.to_csv(output_dir / "building_damage_bygrid_new.csv")
```
